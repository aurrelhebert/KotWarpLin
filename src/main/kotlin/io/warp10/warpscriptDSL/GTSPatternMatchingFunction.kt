package io.warp10.warpscriptDSL
 
// 
// WarpScript KOTLINDSL
// @author aurrelhebert 
// @license apache 2.0 
// 
 
// Autogenerated code
 
fun WarpScript.discords(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DISCORDS"), init) 
} 

fun WarpScript.discords(quantizationScale: Long, patternLength: Long, windowSize: Long, maxDiscords: Long, overlapping: Boolean = false, distanceRatio: Number = 0.0, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to quantizationScale, 2 to patternLength, 3 to windowSize, 4 to maxDiscords, 5 to overlapping, 6 to distanceRatio)
    return initTag(Functions("DISCORDS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.discords(quantizationScale: Long? = null, quantizationScaleElements: Element.() -> Unit = emptyLambda, 
            patternLength: Long? = null, patternLengthElements: Element.() -> Unit = emptyLambda, 
            windowSize: Long? = null, windowSizeElements: Element.() -> Unit = emptyLambda, 
            maxDiscords: Long? = null, maxDiscordsElements: Element.() -> Unit = emptyLambda, 
            overlapping: Boolean? = null, overlappingElements: Element.() -> Unit = emptyLambda, 
            distanceRatio: Number? = null, distanceRatioElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to quantizationScale, 2 to patternLength, 3 to windowSize, 4 to maxDiscords, 5 to overlapping, 6 to distanceRatio)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to quantizationScaleElements, 2 to patternLengthElements, 3 to windowSizeElements, 4 to maxDiscordsElements, 5 to overlappingElements, 6 to distanceRatioElements)
    return initTag(Functions("DISCORDS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.dtw(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DTW"), init) 
} 

fun WarpScript.dtw(threshold: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to threshold)
    return initTag(Functions("DTW", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.dtw(threshold: Double? = null, thresholdElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to threshold)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to thresholdElements)
    return initTag(Functions("DTW", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.optDtw(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("OPTDTW"), init) 
} 

fun WarpScript.optDtw(threshold: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to threshold)
    return initTag(Functions("OPTDTW", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.optDtw(threshold: Double? = null, thresholdElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to threshold)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to thresholdElements)
    return initTag(Functions("OPTDTW", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.patternDetection(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PATTERNDETECTION"), init) 
} 

fun WarpScript.patternDetection(quantizationScale: Long, patternLength: Long, windowSize: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to quantizationScale, 2 to patternLength, 3 to windowSize)
    return initTag(Functions("PATTERNDETECTION", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.patternDetection(quantizationScale: Long? = null, quantizationScaleElements: Element.() -> Unit = emptyLambda, 
            patternLength: Long? = null, patternLengthElements: Element.() -> Unit = emptyLambda, 
            windowSize: Long? = null, windowSizeElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to quantizationScale, 2 to patternLength, 3 to windowSize)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to quantizationScaleElements, 2 to patternLengthElements, 3 to windowSizeElements)
    return initTag(Functions("PATTERNDETECTION", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.patterns(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PATTERNS"), init) 
} 

fun WarpScript.patterns(quantizationScale: Long, patternLength: Long, windowSize: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to quantizationScale, 2 to patternLength, 3 to windowSize)
    return initTag(Functions("PATTERNS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.patterns(quantizationScale: Long? = null, quantizationScaleElements: Element.() -> Unit = emptyLambda, 
            patternLength: Long? = null, patternLengthElements: Element.() -> Unit = emptyLambda, 
            windowSize: Long? = null, windowSizeElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to quantizationScale, 2 to patternLength, 3 to windowSize)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to quantizationScaleElements, 2 to patternLengthElements, 3 to windowSizeElements)
    return initTag(Functions("PATTERNS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.zDiscords(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ZDISCORDS"), init) 
} 

fun WarpScript.zDiscords(quantizationScale: Long, patternLength: Long, windowSize: Long, maxDiscords: Long, overlapping: Boolean = false, distanceRatio: Number = 0.0, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to quantizationScale, 2 to patternLength, 3 to windowSize, 4 to maxDiscords, 5 to overlapping, 6 to distanceRatio)
    return initTag(Functions("ZDISCORDS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.zDiscords(quantizationScale: Long? = null, quantizationScaleElements: Element.() -> Unit = emptyLambda, 
            patternLength: Long? = null, patternLengthElements: Element.() -> Unit = emptyLambda, 
            windowSize: Long? = null, windowSizeElements: Element.() -> Unit = emptyLambda, 
            maxDiscords: Long? = null, maxDiscordsElements: Element.() -> Unit = emptyLambda, 
            overlapping: Boolean? = null, overlappingElements: Element.() -> Unit = emptyLambda, 
            distanceRatio: Number? = null, distanceRatioElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to quantizationScale, 2 to patternLength, 3 to windowSize, 4 to maxDiscords, 5 to overlapping, 6 to distanceRatio)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to quantizationScaleElements, 2 to patternLengthElements, 3 to windowSizeElements, 4 to maxDiscordsElements, 5 to overlappingElements, 6 to distanceRatioElements)
    return initTag(Functions("ZDISCORDS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.zPatternDetection(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ZPATTERNDETECTION"), init) 
} 

fun WarpScript.zPatternDetection(quantizationScale: Long, patternLength: Long, windowSize: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to quantizationScale, 2 to patternLength, 3 to windowSize)
    return initTag(Functions("ZPATTERNDETECTION", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.zPatternDetection(quantizationScale: Long? = null, quantizationScaleElements: Element.() -> Unit = emptyLambda, 
            patternLength: Long? = null, patternLengthElements: Element.() -> Unit = emptyLambda, 
            windowSize: Long? = null, windowSizeElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to quantizationScale, 2 to patternLength, 3 to windowSize)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to quantizationScaleElements, 2 to patternLengthElements, 3 to windowSizeElements)
    return initTag(Functions("ZPATTERNDETECTION", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.zPatterns(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ZPATTERNS"), init) 
} 

fun WarpScript.zPatterns(quantizationScale: Long, patternLength: Long, windowSize: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to quantizationScale, 2 to patternLength, 3 to windowSize)
    return initTag(Functions("ZPATTERNS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.zPatterns(quantizationScale: Long? = null, quantizationScaleElements: Element.() -> Unit = emptyLambda, 
            patternLength: Long? = null, patternLengthElements: Element.() -> Unit = emptyLambda, 
            windowSize: Long? = null, windowSizeElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to quantizationScale, 2 to patternLength, 3 to windowSize)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to quantizationScaleElements, 2 to patternLengthElements, 3 to windowSizeElements)
    return initTag(Functions("ZPATTERNS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.zScore(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ZSCORE"), init) 
} 

fun WarpScript.zScore(flag: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to flag)
    return initTag(Functions("ZSCORE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.zScore(flag: Boolean? = null, flagElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to flag)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to flagElements)
    return initTag(Functions("ZSCORE", data, elements, this, emptyLambda), init) 
} 
