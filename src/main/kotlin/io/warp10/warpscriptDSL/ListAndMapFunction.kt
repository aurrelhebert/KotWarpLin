package io.warp10.warpscriptDSL
 
// 
// WarpScript KOTLINDSL
// @author aurrelhebert 
// @license apache 2.0 
// 
 
// Autogenerated code
 
fun WarpScript.cloneReverse(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CLONEREVERSE"), init) 
} 

fun WarpScript.cloneReverse(value: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("CLONEREVERSE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.cloneReverse(value: List<Any>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("CLONEREVERSE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.contains(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CONTAINS"), init) 
} 

fun WarpScript.contains(input: List<Any>, key: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    return initTag(Functions("CONTAINS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.contains(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            key: Any? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keyElements)
    return initTag(Functions("CONTAINS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.containsKey(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CONTAINSKEY"), init) 
} 

fun WarpScript.containsKey(input: HashMap<Any,Any>, key: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    return initTag(Functions("CONTAINSKEY", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.containsKey(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            key: Any? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keyElements)
    return initTag(Functions("CONTAINSKEY", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.containsValue(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CONTAINSVALUE"), init) 
} 

fun WarpScript.containsValue(input: HashMap<Any,Any>, key: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    return initTag(Functions("CONTAINSVALUE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.containsValue(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            key: Any? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keyElements)
    return initTag(Functions("CONTAINSVALUE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.emptyList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("[]"), init) 
} 

fun WarpScript.emptyMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("{}"), init) 
} 

fun WarpScript.flatten(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FLATTEN"), init) 
} 

fun WarpScript.get(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("GET"), init) 
} 

fun WarpScript.get(index: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to index)
    return initTag(Functions("GET", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.get(index: Long? = null, indexElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to index)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to indexElements)
    return initTag(Functions("GET", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.keyList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("KEYLIST"), init) 
} 

fun WarpScript.keyList(input: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("KEYLIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.keyList(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("KEYLIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.listTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LIST->"), init) 
} 

fun WarpScript.listTo(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("LIST->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.listTo(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("LIST->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mSort(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MSORT"), init) 
} 

fun WarpScript.mSort(input: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("MSORT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mSort(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("MSORT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mapId(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAPID"), init) 
} 

fun WarpScript.mapId(input: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("MAPID", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mapId(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("MAPID", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mapTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAP->"), init) 
} 

fun WarpScript.mapTo(input: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("MAP->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mapTo(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("MAP->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.matTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAT->"), init) 
} 

fun WarpScript.pack(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PACK"), init) 
} 

fun WarpScript.pack(input: List<Any>, format: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to format)
    return initTag(Functions("PACK", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.pack(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            format: String? = null, formatElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to format)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to formatElements)
    return initTag(Functions("PACK", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.size(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SIZE"), init) 
} 

fun WarpScript.size(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("SIZE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.size(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("SIZE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.subList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SUBLIST"), init) 
} 

fun WarpScript.subList(input: List<Any>, indexes: List<Long>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to indexes)
    return initTag(Functions("SUBLIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.subList(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            indexes: List<Long>? = null, indexesElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to indexes)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to indexesElements)
    return initTag(Functions("SUBLIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.subMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SUBMAP"), init) 
} 

fun WarpScript.subMap(input: Map<Any,Any>, keys: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to keys)
    return initTag(Functions("SUBMAP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.subMap(input: Map<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            keys: List<Any>? = null, keysElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to keys)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keysElements)
    return initTag(Functions("SUBMAP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->LIST"), init) 
} 

fun WarpScript.toList(depth: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    return initTag(Functions("->LIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toList(depth: Long? = null, depthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to depthElements)
    return initTag(Functions("->LIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->MAP"), init) 
} 

fun WarpScript.toMap(depth: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    return initTag(Functions("->MAP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toMap(depth: Long? = null, depthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to depthElements)
    return initTag(Functions("->MAP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toMat(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->MAT"), init) 
} 

fun WarpScript.toMat(twoDList: List<List<Number>>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to twoDList)
    return initTag(Functions("->MAT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toMat(twoDList: List<List<Number>>? = null, twoDListElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to twoDList)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to twoDListElements)
    return initTag(Functions("->MAT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toV(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->V"), init) 
} 

fun WarpScript.toV(value: List<Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->V", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toV(value: List<Number>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->V", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toVector(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->VEC"), init) 
} 

fun WarpScript.toVector(value: List<Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->VEC", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toVector(value: List<Number>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->VEC", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNLIST"), init) 
} 

fun WarpScript.unList(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("UNLIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unList(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("UNLIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNMAP"), init) 
} 

fun WarpScript.unMap(input: Map<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("UNMAP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unMap(input: Map<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("UNMAP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unPack(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNPACK"), init) 
} 

fun WarpScript.unPack(format: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to format)
    return initTag(Functions("UNPACK", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unPack(format: String? = null, formatElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to format)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to formatElements)
    return initTag(Functions("UNPACK", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unique(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNIQUE"), init) 
} 

fun WarpScript.unique(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("UNIQUE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unique(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("UNIQUE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.vTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("V->"), init) 
} 

fun WarpScript.valueList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("VALUELIST"), init) 
} 

fun WarpScript.valueList(input: Map<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("VALUELIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.valueList(input: Map<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("VALUELIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.vectorTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("VEC->"), init) 
} 

fun WarpScript.zip(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ZIP"), init) 
} 

fun WarpScript.zip(value: List<List<Any>>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ZIP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.zip(value: List<List<Any>>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ZIP", data, elements, this, emptyLambda), init) 
} 
