package io.warp10.warpscriptDSL
 
// 
// WarpScript KOTLINDSL
// @author aurrelhebert 
// @license apache 2.0 
// 
 
// Autogenerated code
 
fun WarpScript.quaternionConjugate(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QCONJUGATE"), init) 
} 

fun WarpScript.quaternionDivide(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QDIVIDE"), init) 
} 

fun WarpScript.quaternionMultiply(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QMULTIPLY"), init) 
} 

fun WarpScript.quaternionRotate(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QROTATE"), init) 
} 

fun WarpScript.quaternionRotation(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QROTATION"), init) 
} 

fun WarpScript.quaternionTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("Q->"), init) 
} 

fun WarpScript.quaternionTo(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("Q->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.quaternionTo(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("Q->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rotationToQuaternion(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ROTATIONQ"), init) 
} 

fun WarpScript.rotationToQuaternion(w: Double, x: Double, y: Double, z: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to w, 2 to x, 3 to y, 4 to z)
    return initTag(Functions("ROTATIONQ", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rotationToQuaternion(w: Double? = null, wElements: Element.() -> Unit = emptyLambda, 
            x: Double? = null, xElements: Element.() -> Unit = emptyLambda, 
            y: Double? = null, yElements: Element.() -> Unit = emptyLambda, 
            z: Double? = null, zElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to w, 2 to x, 3 to y, 4 to z)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to wElements, 2 to xElements, 3 to yElements, 4 to zElements)
    return initTag(Functions("ROTATIONQ", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toQuaternion(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->Q"), init) 
} 

fun WarpScript.toQuaternion(w: Double, x: Double, y: Double, z: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to w, 2 to x, 3 to y, 4 to z)
    return initTag(Functions("->Q", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toQuaternion(w: Double? = null, wElements: Element.() -> Unit = emptyLambda, 
            x: Double? = null, xElements: Element.() -> Unit = emptyLambda, 
            y: Double? = null, yElements: Element.() -> Unit = emptyLambda, 
            z: Double? = null, zElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to w, 2 to x, 3 to y, 4 to z)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to wElements, 2 to xElements, 3 to yElements, 4 to zElements)
    return initTag(Functions("->Q", data, elements, this, emptyLambda), init) 
} 
