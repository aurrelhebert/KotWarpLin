package io.warp10.warpscriptDSL
 
// 
// WarpScript KOTLINDSL
// @author aurrelhebert 
// @license apache 2.0 
// 
 
// Autogenerated code
 
fun WarpScript.aesUnwrap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("AESUNWRAP"), init) 
} 

fun WarpScript.aesWrap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("AESWRAP"), init) 
} 

fun WarpScript.append(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("APPEND"), init) 
} 

fun WarpScript.append(p1: List<Any>, p2: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("APPEND", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.append(p1: List<Any>? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: List<Any>? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("APPEND", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.assert(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ASSERT"), init) 
} 

fun WarpScript.assert(value: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ASSERT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.assert(value: Boolean? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ASSERT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.authenticate(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("AUTHENTICATE"), init) 
} 

fun WarpScript.authenticate(token: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to token)
    return initTag(Functions("AUTHENTICATE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.authenticate(token: String? = null, tokenElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to token)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to tokenElements)
    return initTag(Functions("AUTHENTICATE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.bootstrap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BOOTSTRAP"), init) 
} 

fun WarpScript.breakWarp10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BREAK"), init) 
} 

fun WarpScript.cachedUdf(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CUDF"), init) 
} 

fun WarpScript.cachedUdf(className: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to className)
    return initTag(Functions("CUDF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.cachedUdf(className: String? = null, classNameElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to className)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to classNameElements)
    return initTag(Functions("CUDF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.call(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CALL"), init) 
} 

fun WarpScript.clear(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CLEAR"), init) 
} 

fun WarpScript.clearDefs(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CLEARDEFS"), init) 
} 

fun WarpScript.clearSymbols(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CLEARSYMBOLS"), init) 
} 

fun WarpScript.clearToMark(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CLEARTOMARK"), init) 
} 

fun WarpScript.cloneReverse(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CLONEREVERSE"), init) 
} 

fun WarpScript.cloneReverse(value: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("CLONEREVERSE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.cloneReverse(value: List<Any>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("CLONEREVERSE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.closeList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("]"), init) 
} 

fun WarpScript.closeMacro(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("%>"), init) 
} 

fun WarpScript.closeMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("}"), init) 
} 

fun WarpScript.closeSafeScript(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("S>"), init) 
} 

fun WarpScript.contains(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CONTAINS"), init) 
} 

fun WarpScript.contains(input: List<Any>, key: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    return initTag(Functions("CONTAINS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.contains(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            key: Any? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keyElements)
    return initTag(Functions("CONTAINS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.containsKey(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CONTAINSKEY"), init) 
} 

fun WarpScript.containsKey(input: HashMap<Any,Any>, key: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    return initTag(Functions("CONTAINSKEY", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.containsKey(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            key: Any? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keyElements)
    return initTag(Functions("CONTAINSKEY", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.containsValue(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CONTAINSVALUE"), init) 
} 

fun WarpScript.containsValue(input: HashMap<Any,Any>, key: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    return initTag(Functions("CONTAINSVALUE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.containsValue(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            key: Any? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keyElements)
    return initTag(Functions("CONTAINSVALUE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.continueWarp10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CONTINUE"), init) 
} 

fun WarpScript.countToMark(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COUNTTOMARK"), init) 
} 

fun WarpScript.debugoff(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DEBUGOFF"), init) 
} 

fun WarpScript.debugon(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DEBUGON"), init) 
} 

fun WarpScript.def(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DEF"), init) 
} 

fun WarpScript.def(name: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to name)
    return initTag(Functions("DEF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.def(name: String? = null, nameElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to name)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nameElements)
    return initTag(Functions("DEF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.defined(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DEFINED"), init) 
} 

fun WarpScript.defined(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("DEFINED", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.defined(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("DEFINED", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.definedMacro(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DEFINEDMACRO"), init) 
} 

fun WarpScript.definedMacro(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("DEFINEDMACRO", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.definedMacro(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("DEFINEDMACRO", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.depth(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DEPTH"), init) 
} 

fun WarpScript.difference(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DIFFERENCE"), init) 
} 

fun WarpScript.doc(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DOC"), init) 
} 

fun WarpScript.doc(documentation: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to documentation)
    return initTag(Functions("DOC", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.doc(documentation: String? = null, documentationElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to documentation)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to documentationElements)
    return initTag(Functions("DOC", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.docMode(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DOCMODE"), init) 
} 

fun WarpScript.drop(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DROP"), init) 
} 

fun WarpScript.dropn(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DROPN"), init) 
} 

fun WarpScript.dropn(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("DROPN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.dropn(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("DROPN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.dup(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DUP"), init) 
} 

fun WarpScript.dup(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("DUP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.dup(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("DUP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.dupn(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DUPN"), init) 
} 

fun WarpScript.dupn(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("DUPN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.dupn(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("DUPN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.elapsed(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ELAPSED"), init) 
} 

fun WarpScript.emptyList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("[]"), init) 
} 

fun WarpScript.emptyMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("{}"), init) 
} 

fun WarpScript.eval(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("EVAL"), init) 
} 

fun WarpScript.eval(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("EVAL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.eval(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("EVAL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.evalSecure(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("EVALSECURE"), init) 
} 

fun WarpScript.evalSecure(statement: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to statement)
    return initTag(Functions("EVALSECURE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.evalSecure(statement: String? = null, statementElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to statement)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to statementElements)
    return initTag(Functions("EVALSECURE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.exportList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("EXPORT"), init) 
} 

fun WarpScript.exportList(values: List<String>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to values)
    return initTag(Functions("EXPORT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.exportList(values: List<String>? = null, valuesElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to values)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valuesElements)
    return initTag(Functions("EXPORT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.exportSymbol(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("EXPORT"), init) 
} 

fun WarpScript.exportSymbol(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("EXPORT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.exportSymbol(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("EXPORT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.fail(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FAIL"), init) 
} 

fun WarpScript.flatten(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FLATTEN"), init) 
} 

fun WarpScript.forget(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FORGET"), init) 
} 

fun WarpScript.forget(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("FORGET", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.forget(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("FORGET", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.get(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("GET"), init) 
} 

fun WarpScript.get(index: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to index)
    return initTag(Functions("GET", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.get(index: Long? = null, indexElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to index)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to indexElements)
    return initTag(Functions("GET", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.gzip(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("GZIP"), init) 
} 

fun WarpScript.gzip(input: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("GZIP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.gzip(input: String? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("GZIP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.header(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("HEADER"), init) 
} 

fun WarpScript.header(key: String, value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to key, 2 to value)
    return initTag(Functions("HEADER", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.header(key: String? = null, keyElements: Element.() -> Unit = emptyLambda, 
            value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to key, 2 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to keyElements, 2 to valueElements)
    return initTag(Functions("HEADER", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.ident(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("IDENT"), init) 
} 

fun WarpScript.intersection(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("INTERSECTION"), init) 
} 

fun WarpScript.jsonLoose(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("JSONLOOSE"), init) 
} 

fun WarpScript.jsonStrict(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("JSONSTRICT"), init) 
} 

fun WarpScript.keyList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("KEYLIST"), init) 
} 

fun WarpScript.keyList(input: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("KEYLIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.keyList(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("KEYLIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.lSort(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LSORT"), init) 
} 

fun WarpScript.lSort(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("LSORT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.lSort(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("LSORT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.limit(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LIMIT"), init) 
} 

fun WarpScript.limit(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("LIMIT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.limit(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("LIMIT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.listTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LIST->"), init) 
} 

fun WarpScript.listTo(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("LIST->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.listTo(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("LIST->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mSort(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MSORT"), init) 
} 

fun WarpScript.mSort(input: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("MSORT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mSort(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("MSORT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mapId(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAPID"), init) 
} 

fun WarpScript.mapId(input: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("MAPID", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mapId(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("MAPID", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mapTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAP->"), init) 
} 

fun WarpScript.mapTo(input: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("MAP->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mapTo(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("MAP->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mark(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MARK"), init) 
} 

fun WarpScript.matTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAT->"), init) 
} 

fun WarpScript.maxBuckets(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAXBUCKETS"), init) 
} 

fun WarpScript.maxBuckets(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("MAXBUCKETS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.maxBuckets(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("MAXBUCKETS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.maxDepth(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAXDEPTH"), init) 
} 

fun WarpScript.maxDepth(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("MAXDEPTH", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.maxDepth(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("MAXDEPTH", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.maxGts(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAXGTS"), init) 
} 

fun WarpScript.maxGts(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("MAXGTS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.maxGts(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("MAXGTS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.maxLoop(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAXLOOP"), init) 
} 

fun WarpScript.maxLoop(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("MAXLOOP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.maxLoop(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("MAXLOOP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.maxOps(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAXOPS"), init) 
} 

fun WarpScript.maxOps(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("MAXOPS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.maxOps(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("MAXOPS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.maxSymbols(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAXSYMBOLS"), init) 
} 

fun WarpScript.maxSymbols(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("MAXSYMBOLS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.maxSymbols(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("MAXSYMBOLS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.md5(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MD5"), init) 
} 

fun WarpScript.msgFail(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MSGFAIL"), init) 
} 

fun WarpScript.msgFail(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("MSGFAIL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.msgFail(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("MSGFAIL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nDebugOn(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NDEBUGON"), init) 
} 

fun WarpScript.nDebugOn(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("NDEBUGON", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.nDebugOn(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("NDEBUGON", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nReturn(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NRETURN"), init) 
} 

fun WarpScript.nReturn(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("NRETURN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.nReturn(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("NRETURN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.noTimings(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NOTIMINGS"), init) 
} 

fun WarpScript.openList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("["), init) 
} 

fun WarpScript.openMacro(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<%"), init) 
} 

fun WarpScript.openMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("{"), init) 
} 

fun WarpScript.openSafeScript(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<S"), init) 
} 

fun WarpScript.ops(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("OPS"), init) 
} 

fun WarpScript.pack(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PACK"), init) 
} 

fun WarpScript.pack(input: List<Any>, format: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to format)
    return initTag(Functions("PACK", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.pack(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            format: String? = null, formatElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to format)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to formatElements)
    return initTag(Functions("PACK", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.pick(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PICK"), init) 
} 

fun WarpScript.pick(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("PICK", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.pick(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("PICK", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.put(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PUT"), init) 
} 

fun WarpScript.put(input: HashMap<Any,Any>, value: Any, key: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to value, 3 to key)
    return initTag(Functions("PUT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.put(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            key: Any? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to value, 3 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to valueElements, 3 to keyElements)
    return initTag(Functions("PUT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rExec(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REXEC"), init) 
} 

fun WarpScript.rExec(code: String, url: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to code, 2 to url)
    return initTag(Functions("REXEC", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rExec(code: String? = null, codeElements: Element.() -> Unit = emptyLambda, 
            url: String? = null, urlElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to code, 2 to url)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to codeElements, 2 to urlElements)
    return initTag(Functions("REXEC", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.removeList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REMOVE"), init) 
} 

fun WarpScript.removeList(input: List<Any>, index: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to index)
    return initTag(Functions("REMOVE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.removeList(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            index: Any? = null, indexElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to index)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to indexElements)
    return initTag(Functions("REMOVE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.removeMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REMOVE"), init) 
} 

fun WarpScript.removeMap(input: Map<Any,Any>, key: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    return initTag(Functions("REMOVE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.removeMap(input: Map<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            key: Any? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keyElements)
    return initTag(Functions("REMOVE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.reset(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RESET"), init) 
} 

fun WarpScript.reset(depth: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    return initTag(Functions("RESET", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.reset(depth: Long? = null, depthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to depthElements)
    return initTag(Functions("RESET", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.restore(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RESTORE"), init) 
} 

fun WarpScript.returnWarp10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RETURN"), init) 
} 

fun WarpScript.rev(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REV"), init) 
} 

fun WarpScript.reverse(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REVERSE"), init) 
} 

fun WarpScript.reverse(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("REVERSE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.reverse(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("REVERSE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.roll(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ROLL"), init) 
} 

fun WarpScript.roll(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("ROLL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.roll(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("ROLL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rollD(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ROLLD"), init) 
} 

fun WarpScript.rollD(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("ROLLD", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rollD(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("ROLLD", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rot(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ROT"), init) 
} 

fun WarpScript.rsaDecrypt(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSADECRYPT"), init) 
} 

fun WarpScript.rsaEncrypt(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSAENCRYPT"), init) 
} 

fun WarpScript.rsaGen(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSAGEN"), init) 
} 

fun WarpScript.rsaGen(exponent: String, keyLength: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to exponent, 2 to keyLength)
    return initTag(Functions("RSAGEN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rsaGen(exponent: String? = null, exponentElements: Element.() -> Unit = emptyLambda, 
            keyLength: Long? = null, keyLengthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to exponent, 2 to keyLength)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to exponentElements, 2 to keyLengthElements)
    return initTag(Functions("RSAGEN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rsaPrivate(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSAPRIVATE"), init) 
} 

fun WarpScript.rsaPrivate(parameter: HashMap<String,String>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to parameter)
    return initTag(Functions("RSAPRIVATE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rsaPrivate(parameter: HashMap<String,String>? = null, parameterElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to parameter)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to parameterElements)
    return initTag(Functions("RSAPRIVATE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rsaPublic(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSAPUBLIC"), init) 
} 

fun WarpScript.rsaPublic(parameter: HashMap<String,String>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to parameter)
    return initTag(Functions("RSAPUBLIC", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rsaPublic(parameter: HashMap<String,String>? = null, parameterElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to parameter)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to parameterElements)
    return initTag(Functions("RSAPUBLIC", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rsaSign(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSASIGN"), init) 
} 

fun WarpScript.rsaVerify(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSAVERIFY"), init) 
} 

fun WarpScript.run(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RUN"), init) 
} 

fun WarpScript.run(name: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to name)
    return initTag(Functions("RUN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.run(name: String? = null, nameElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to name)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nameElements)
    return initTag(Functions("RUN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.save(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SAVE"), init) 
} 

fun WarpScript.secureKey(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SECUREKEY"), init) 
} 

fun WarpScript.secureKey(key: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to key)
    return initTag(Functions("SECUREKEY", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.secureKey(key: String? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to keyElements)
    return initTag(Functions("SECUREKEY", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.set(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SET"), init) 
} 

fun WarpScript.set(input: List<Any>, elem: Any, index: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to elem, 3 to index)
    return initTag(Functions("SET", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.set(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            elem: Any? = null, elemElements: Element.() -> Unit = emptyLambda, 
            index: Long? = null, indexElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to elem, 3 to index)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to elemElements, 3 to indexElements)
    return initTag(Functions("SET", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.setTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SET->"), init) 
} 

fun WarpScript.sha1(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SHA1"), init) 
} 

fun WarpScript.sha1Hmac(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SHA1HMAC"), init) 
} 

fun WarpScript.sha256(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SHA256"), init) 
} 

fun WarpScript.sha256Hmac(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SHA256HMAC"), init) 
} 

fun WarpScript.size(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SIZE"), init) 
} 

fun WarpScript.size(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("SIZE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.size(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("SIZE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.snapshot(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SNAPSHOT"), init) 
} 

fun WarpScript.snapshotAll(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SNAPSHOTALL"), init) 
} 

fun WarpScript.snapshotAllToMark(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SNAPSHOTALLTOMARK"), init) 
} 

fun WarpScript.snapshotToMark(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SNAPSHOTTOMARK"), init) 
} 

fun WarpScript.stackAttribute(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("STACKATTRIBUTE"), init) 
} 

fun WarpScript.stackAttribute(attribute: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to attribute)
    return initTag(Functions("STACKATTRIBUTE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.stackAttribute(attribute: String? = null, attributeElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to attribute)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to attributeElements)
    return initTag(Functions("STACKATTRIBUTE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.stackToList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("STACKTOLIST"), init) 
} 

fun WarpScript.stop(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("STOP"), init) 
} 

fun WarpScript.subList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SUBLIST"), init) 
} 

fun WarpScript.subList(input: List<Any>, indexes: List<Long>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to indexes)
    return initTag(Functions("SUBLIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.subList(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            indexes: List<Long>? = null, indexesElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to indexes)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to indexesElements)
    return initTag(Functions("SUBLIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.subMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SUBMAP"), init) 
} 

fun WarpScript.subMap(input: Map<Any,Any>, keys: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to keys)
    return initTag(Functions("SUBMAP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.subMap(input: Map<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            keys: List<Any>? = null, keysElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to keys)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keysElements)
    return initTag(Functions("SUBMAP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.swap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SWAP"), init) 
} 

fun WarpScript.timings(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TIMINGS"), init) 
} 

fun WarpScript.toList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->LIST"), init) 
} 

fun WarpScript.toList(depth: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    return initTag(Functions("->LIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toList(depth: Long? = null, depthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to depthElements)
    return initTag(Functions("->LIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->MAP"), init) 
} 

fun WarpScript.toMap(depth: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    return initTag(Functions("->MAP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toMap(depth: Long? = null, depthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to depthElements)
    return initTag(Functions("->MAP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toMat(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->MAT"), init) 
} 

fun WarpScript.toMat(twoDList: List<List<Number>>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to twoDList)
    return initTag(Functions("->MAT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toMat(twoDList: List<List<Number>>? = null, twoDListElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to twoDList)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to twoDListElements)
    return initTag(Functions("->MAT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toSet(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->SET"), init) 
} 

fun WarpScript.toSet(value: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->SET", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toSet(value: List<Any>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->SET", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toV(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->V"), init) 
} 

fun WarpScript.toV(value: List<Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->V", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toV(value: List<Number>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->V", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toVector(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->VEC"), init) 
} 

fun WarpScript.toVector(value: List<Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->VEC", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toVector(value: List<Number>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->VEC", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toZOrderCurve(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->Z"), init) 
} 

fun WarpScript.toZOrderCurve(parameter: List<Long>, bitwidth: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to parameter, 2 to bitwidth)
    return initTag(Functions("->Z", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toZOrderCurve(parameter: List<Long>? = null, parameterElements: Element.() -> Unit = emptyLambda, 
            bitwidth: Long? = null, bitwidthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to parameter, 2 to bitwidth)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to parameterElements, 2 to bitwidthElements)
    return initTag(Functions("->Z", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.tokenInfo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TOKENINFO"), init) 
} 

fun WarpScript.tokenInfo(token: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to token)
    return initTag(Functions("TOKENINFO", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.tokenInfo(token: String? = null, tokenElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to token)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to tokenElements)
    return initTag(Functions("TOKENINFO", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.typeOf(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TYPEOF"), init) 
} 

fun WarpScript.typeOf(element: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to element)
    return initTag(Functions("TYPEOF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.typeOf(element: Any? = null, elementElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to element)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to elementElements)
    return initTag(Functions("TYPEOF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.udf(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UDF"), init) 
} 

fun WarpScript.udf(className: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to className)
    return initTag(Functions("UDF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.udf(className: String? = null, classNameElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to className)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to classNameElements)
    return initTag(Functions("UDF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unGzip(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNGZIP"), init) 
} 

fun WarpScript.unList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNLIST"), init) 
} 

fun WarpScript.unList(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("UNLIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unList(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("UNLIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNMAP"), init) 
} 

fun WarpScript.unMap(input: Map<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("UNMAP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unMap(input: Map<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("UNMAP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unPack(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNPACK"), init) 
} 

fun WarpScript.unPack(format: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to format)
    return initTag(Functions("UNPACK", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unPack(format: String? = null, formatElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to format)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to formatElements)
    return initTag(Functions("UNPACK", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.union(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNION"), init) 
} 

fun WarpScript.unique(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNIQUE"), init) 
} 

fun WarpScript.unique(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("UNIQUE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unique(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("UNIQUE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unsecure(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNSECURE"), init) 
} 

fun WarpScript.urlFetch(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("URLFETCH"), init) 
} 

fun WarpScript.vTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("V->"), init) 
} 

fun WarpScript.valueList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("VALUELIST"), init) 
} 

fun WarpScript.valueList(input: Map<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("VALUELIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.valueList(input: Map<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("VALUELIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.vectorTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("VEC->"), init) 
} 

fun WarpScript.webCall(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("WEBCALL"), init) 
} 

fun WarpScript.webCall(token: String, method: String, url: String, headers: HashMap<String,String>, body: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to token, 2 to method, 3 to url, 4 to headers, 5 to body)
    return initTag(Functions("WEBCALL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.webCall(token: String? = null, tokenElements: Element.() -> Unit = emptyLambda, 
            method: String? = null, methodElements: Element.() -> Unit = emptyLambda, 
            url: String? = null, urlElements: Element.() -> Unit = emptyLambda, 
            headers: HashMap<String,String>? = null, headersElements: Element.() -> Unit = emptyLambda, 
            body: String? = null, bodyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to token, 2 to method, 3 to url, 4 to headers, 5 to body)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to tokenElements, 2 to methodElements, 3 to urlElements, 4 to headersElements, 5 to bodyElements)
    return initTag(Functions("WEBCALL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.zOrderCurveTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("Z->"), init) 
} 

fun WarpScript.zOrderCurveTo(numberOfComponents: Long, bitWidth: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to numberOfComponents, 2 to bitWidth)
    return initTag(Functions("Z->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.zOrderCurveTo(numberOfComponents: Long? = null, numberOfComponentsElements: Element.() -> Unit = emptyLambda, 
            bitWidth: Long? = null, bitWidthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to numberOfComponents, 2 to bitWidth)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberOfComponentsElements, 2 to bitWidthElements)
    return initTag(Functions("Z->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.zip(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ZIP"), init) 
} 

fun WarpScript.zip(value: List<List<Any>>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ZIP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.zip(value: List<List<Any>>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ZIP", data, elements, this, emptyLambda), init) 
} 
