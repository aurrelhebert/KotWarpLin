package io.warp10.warpscriptDSL
 
// 
// WarpScript KOTLINDSL
// @author aurrelhebert 
// @license apache 2.0 
// 
 
// Autogenerated code
 
fun WarpScript.abs(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ABS"), init) 
} 

fun WarpScript.abs(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ABS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.abs(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ABS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.acos(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ACOS"), init) 
} 

fun WarpScript.acos(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ACOS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.acos(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ACOS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.add(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+"), init) 
} 

fun WarpScript.add(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("+", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.add(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("+", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addDays(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ADDDAYS"), init) 
} 

fun WarpScript.addDays(timestamp: Long, NumberOfDaysToAdd: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to NumberOfDaysToAdd)
    return initTag(Functions("ADDDAYS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addDays(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            NumberOfDaysToAdd: Long? = null, NumberOfDaysToAddElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to NumberOfDaysToAdd)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to NumberOfDaysToAddElements)
    return initTag(Functions("ADDDAYS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addDaysWithTimeZone(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ADDDAYS"), init) 
} 

fun WarpScript.addDaysWithTimeZone(timestamp: Long, timeZone: String, NumberOfDaysToAdd: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone, 3 to NumberOfDaysToAdd)
    return initTag(Functions("ADDDAYS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addDaysWithTimeZone(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            timeZone: String? = null, timeZoneElements: Element.() -> Unit = emptyLambda, 
            NumberOfDaysToAdd: Long? = null, NumberOfDaysToAddElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone, 3 to NumberOfDaysToAdd)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to timeZoneElements, 3 to NumberOfDaysToAddElements)
    return initTag(Functions("ADDDAYS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addMonths(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ADDMONTHS"), init) 
} 

fun WarpScript.addMonths(timestamp: Long, NumberOfMonthsToAdd: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to NumberOfMonthsToAdd)
    return initTag(Functions("ADDMONTHS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addMonths(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            NumberOfMonthsToAdd: Long? = null, NumberOfMonthsToAddElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to NumberOfMonthsToAdd)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to NumberOfMonthsToAddElements)
    return initTag(Functions("ADDMONTHS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addMonthsWithTimeZone(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ADDMONTHS"), init) 
} 

fun WarpScript.addMonthsWithTimeZone(timestamp: Long, timeZone: String, NumberOfMonthsToAdd: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone, 3 to NumberOfMonthsToAdd)
    return initTag(Functions("ADDMONTHS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addMonthsWithTimeZone(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            timeZone: String? = null, timeZoneElements: Element.() -> Unit = emptyLambda, 
            NumberOfMonthsToAdd: Long? = null, NumberOfMonthsToAddElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone, 3 to NumberOfMonthsToAdd)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to timeZoneElements, 3 to NumberOfMonthsToAddElements)
    return initTag(Functions("ADDMONTHS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToCloneList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+"), init) 
} 

fun WarpScript.addToCloneList(p1: List<Any>, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("+", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToCloneList(p1: List<Any>? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("+", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToExistingList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+!"), init) 
} 

fun WarpScript.addToExistingList(p1: List<Any>, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("+!", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToExistingList(p1: List<Any>? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("+!", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToExistingListFromStack(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+!"), init) 
} 

fun WarpScript.addToExistingListFromStack(element: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(2 to element)
    return initTag(Functions("+!", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToExistingListFromStack(element: Any? = null, elementElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(2 to element)
    val elements = hashMapOf<Number, Element.() -> Unit>(2 to elementElements)
    return initTag(Functions("+!", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToStackElement(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+"), init) 
} 

fun WarpScript.addToStackElement(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(2 to value)
    return initTag(Functions("+", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToStackElement(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(2 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(2 to valueElements)
    return initTag(Functions("+", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addYears(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ADDYEARS"), init) 
} 

fun WarpScript.addYears(timestamp: Long, NumberOfYearsToAdd: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to NumberOfYearsToAdd)
    return initTag(Functions("ADDYEARS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addYears(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            NumberOfYearsToAdd: Long? = null, NumberOfYearsToAddElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to NumberOfYearsToAdd)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to NumberOfYearsToAddElements)
    return initTag(Functions("ADDYEARS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addYearsWithTimeZone(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ADDYEARS"), init) 
} 

fun WarpScript.addYearsWithTimeZone(timestamp: Long, timeZone: String, NumberOfYearsToAdd: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone, 3 to NumberOfYearsToAdd)
    return initTag(Functions("ADDYEARS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addYearsWithTimeZone(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            timeZone: String? = null, timeZoneElements: Element.() -> Unit = emptyLambda, 
            NumberOfYearsToAdd: Long? = null, NumberOfYearsToAddElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone, 3 to NumberOfYearsToAdd)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to timeZoneElements, 3 to NumberOfYearsToAddElements)
    return initTag(Functions("ADDYEARS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.aesUnwrap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("AESUNWRAP"), init) 
} 

fun WarpScript.aesWrap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("AESWRAP"), init) 
} 

fun WarpScript.ago(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("AGO"), init) 
} 

fun WarpScript.ago(duration: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to duration)
    return initTag(Functions("AGO", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ago(duration: Long? = null, durationElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to duration)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to durationElements)
    return initTag(Functions("AGO", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.and(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("&&"), init) 
} 

fun WarpScript.and(p1: Boolean, p2: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("&&", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.and(p1: Boolean? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Boolean? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("&&", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.andBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("&"), init) 
} 

fun WarpScript.andBitWise(p1: Long, p2: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("&", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.andBitWise(p1: Long? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Long? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("&", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.append(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("APPEND"), init) 
} 

fun WarpScript.append(p1: List<Any>, p2: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("APPEND", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.append(p1: List<Any>? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: List<Any>? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("APPEND", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.asin(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ASIN"), init) 
} 

fun WarpScript.asin(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ASIN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.asin(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ASIN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.assert(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ASSERT"), init) 
} 

fun WarpScript.assert(value: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ASSERT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.assert(value: Boolean? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ASSERT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.atan(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ATAN"), init) 
} 

fun WarpScript.atan(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ATAN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.atan(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ATAN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.authenticate(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("AUTHENTICATE"), init) 
} 

fun WarpScript.authenticate(token: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to token)
    return initTag(Functions("AUTHENTICATE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.authenticate(token: String? = null, tokenElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to token)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to tokenElements)
    return initTag(Functions("AUTHENTICATE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.base64To(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("B64->"), init) 
} 

fun WarpScript.base64To(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("B64->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.base64To(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("B64->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.base64ToHex(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("B64TOHEX"), init) 
} 

fun WarpScript.base64ToHex(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("B64TOHEX", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.base64ToHex(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("B64TOHEX", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.base64UrlTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("B64URL->"), init) 
} 

fun WarpScript.base64UrlTo(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("B64URL->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.base64UrlTo(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("B64URL->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.binTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BIN->"), init) 
} 

fun WarpScript.binTo(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("BIN->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.binTo(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("BIN->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.binToHex(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BINTOHEX"), init) 
} 

fun WarpScript.binToHex(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("BINTOHEX", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.binToHex(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("BINTOHEX", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.bitCount(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BITCOUNT"), init) 
} 

fun WarpScript.bitGet(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BITGET"), init) 
} 

fun WarpScript.bitGet(index: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to index)
    return initTag(Functions("BITGET", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.bitGet(index: Long? = null, indexElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to index)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to indexElements)
    return initTag(Functions("BITGET", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.bitsToBytes(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BITSTOBYTES"), init) 
} 

fun WarpScript.bootstrap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BOOTSTRAP"), init) 
} 

fun WarpScript.breakWarp10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BREAK"), init) 
} 

fun WarpScript.bytesTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BYTES->"), init) 
} 

fun WarpScript.bytesTo(charset: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to charset)
    return initTag(Functions("BYTES->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.bytesTo(charset: String? = null, charsetElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to charset)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to charsetElements)
    return initTag(Functions("BYTES->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.bytesToBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BYTESTOBITS"), init) 
} 

fun WarpScript.cachedUdf(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CUDF"), init) 
} 

fun WarpScript.cachedUdf(className: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to className)
    return initTag(Functions("CUDF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.cachedUdf(className: String? = null, classNameElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to className)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to classNameElements)
    return initTag(Functions("CUDF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.call(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CALL"), init) 
} 

fun WarpScript.ceil(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CEIL"), init) 
} 

fun WarpScript.ceil(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("CEIL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ceil(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("CEIL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.clear(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CLEAR"), init) 
} 

fun WarpScript.clearDefs(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CLEARDEFS"), init) 
} 

fun WarpScript.clearSymbols(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CLEARSYMBOLS"), init) 
} 

fun WarpScript.clearToMark(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CLEARTOMARK"), init) 
} 

fun WarpScript.cloneReverse(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CLONEREVERSE"), init) 
} 

fun WarpScript.cloneReverse(value: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("CLONEREVERSE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.cloneReverse(value: List<Any>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("CLONEREVERSE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.closeList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("]"), init) 
} 

fun WarpScript.closeMacro(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("%>"), init) 
} 

fun WarpScript.closeMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("}"), init) 
} 

fun WarpScript.contains(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CONTAINS"), init) 
} 

fun WarpScript.contains(input: List<Any>, key: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    return initTag(Functions("CONTAINS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.contains(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            key: Any? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keyElements)
    return initTag(Functions("CONTAINS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.containsKey(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CONTAINSKEY"), init) 
} 

fun WarpScript.containsKey(input: HashMap<Any,Any>, key: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    return initTag(Functions("CONTAINSKEY", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.containsKey(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            key: Any? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keyElements)
    return initTag(Functions("CONTAINSKEY", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.containsValue(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CONTAINSVALUE"), init) 
} 

fun WarpScript.containsValue(input: HashMap<Any,Any>, key: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    return initTag(Functions("CONTAINSVALUE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.containsValue(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            key: Any? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keyElements)
    return initTag(Functions("CONTAINSVALUE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.continueWarp10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CONTINUE"), init) 
} 

fun WarpScript.copySign(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COPYSIGN"), init) 
} 

fun WarpScript.copySign(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("COPYSIGN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.copySign(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("COPYSIGN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.cos(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COS"), init) 
} 

fun WarpScript.cos(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("COS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.cos(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("COS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.cosh(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COSH"), init) 
} 

fun WarpScript.cosh(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("COSH", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.cosh(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("COSH", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.countToMark(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COUNTTOMARK"), init) 
} 

fun WarpScript.counter(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COUNTER"), init) 
} 

fun WarpScript.counterDelta(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COUNTERDELTA"), init) 
} 

fun WarpScript.counterDelta(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("COUNTERDELTA", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.counterDelta(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("COUNTERDELTA", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.counterValue(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COUNTERVALUE"), init) 
} 

fun WarpScript.cubicRoot(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CBRT"), init) 
} 

fun WarpScript.cubicRoot(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("CBRT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.cubicRoot(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("CBRT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.d(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("d"), init) 
} 

fun WarpScript.d(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("d", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.d(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("d", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.debugoff(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DEBUGOFF"), init) 
} 

fun WarpScript.debugon(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DEBUGON"), init) 
} 

fun WarpScript.def(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DEF"), init) 
} 

fun WarpScript.def(name: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to name)
    return initTag(Functions("DEF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.def(name: String? = null, nameElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to name)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nameElements)
    return initTag(Functions("DEF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.defined(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DEFINED"), init) 
} 

fun WarpScript.defined(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("DEFINED", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.defined(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("DEFINED", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.definedMacro(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DEFINEDMACRO"), init) 
} 

fun WarpScript.definedMacro(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("DEFINEDMACRO", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.definedMacro(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("DEFINEDMACRO", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.depth(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DEPTH"), init) 
} 

fun WarpScript.difference(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DIFFERENCE"), init) 
} 

fun WarpScript.div(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("/"), init) 
} 

fun WarpScript.div(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("/", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.div(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("/", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.doc(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DOC"), init) 
} 

fun WarpScript.doc(documentation: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to documentation)
    return initTag(Functions("DOC", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.doc(documentation: String? = null, documentationElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to documentation)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to documentationElements)
    return initTag(Functions("DOC", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.docMode(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DOCMODE"), init) 
} 

fun WarpScript.doubleToBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->DOUBLEBITS"), init) 
} 

fun WarpScript.doubleToBits(value: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->DOUBLEBITS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.doubleToBits(value: Double? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->DOUBLEBITS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.doubleToFloatToBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->FLOATBITS"), init) 
} 

fun WarpScript.doubleToFloatToBits(value: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->FLOATBITS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.doubleToFloatToBits(value: Double? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->FLOATBITS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.drop(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DROP"), init) 
} 

fun WarpScript.dropn(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DROPN"), init) 
} 

fun WarpScript.dropn(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("DROPN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.dropn(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("DROPN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.dup(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DUP"), init) 
} 

fun WarpScript.dup(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("DUP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.dup(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("DUP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.dupn(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DUPN"), init) 
} 

fun WarpScript.dupn(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("DUPN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.dupn(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("DUPN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.duration(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DURATION"), init) 
} 

fun WarpScript.duration(ISO8601Duration: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to ISO8601Duration)
    return initTag(Functions("DURATION", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.duration(ISO8601Duration: String? = null, ISO8601DurationElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to ISO8601Duration)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to ISO8601DurationElements)
    return initTag(Functions("DURATION", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.elapsed(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ELAPSED"), init) 
} 

fun WarpScript.emptyList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("[]"), init) 
} 

fun WarpScript.emptyMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("{}"), init) 
} 

fun WarpScript.equal(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("=="), init) 
} 

fun WarpScript.equal(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("==", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.equal(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("==", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.equalWithToleranceFactor(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("~="), init) 
} 

fun WarpScript.equalWithToleranceFactor(p1: Number, p2: Number, lambda: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2, 3 to lambda)
    return initTag(Functions("~=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.equalWithToleranceFactor(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            lambda: Number? = null, lambdaElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2, 3 to lambda)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements, 3 to lambdaElements)
    return initTag(Functions("~=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.eulerConstant(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("e"), init) 
} 

fun WarpScript.eulerNumber(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("EXP"), init) 
} 

fun WarpScript.eulerNumber(power: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to power)
    return initTag(Functions("EXP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.eulerNumber(power: Long? = null, powerElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to power)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to powerElements)
    return initTag(Functions("EXP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.eval(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("EVAL"), init) 
} 

fun WarpScript.eval(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("EVAL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.eval(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("EVAL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.exp(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("**"), init) 
} 

fun WarpScript.exp(base: Number, power: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to base, 2 to power)
    return initTag(Functions("**", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.exp(base: Number? = null, baseElements: Element.() -> Unit = emptyLambda, 
            power: Number? = null, powerElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to base, 2 to power)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to baseElements, 2 to powerElements)
    return initTag(Functions("**", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.exportList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("EXPORT"), init) 
} 

fun WarpScript.exportList(values: List<String>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to values)
    return initTag(Functions("EXPORT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.exportList(values: List<String>? = null, valuesElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to values)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valuesElements)
    return initTag(Functions("EXPORT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.exportSymbol(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("EXPORT"), init) 
} 

fun WarpScript.exportSymbol(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("EXPORT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.exportSymbol(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("EXPORT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.fail(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FAIL"), init) 
} 

fun WarpScript.flatten(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FLATTEN"), init) 
} 

fun WarpScript.floor(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FLOOR"), init) 
} 

fun WarpScript.floor(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("FLOOR", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.floor(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("FLOOR", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.forget(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FORGET"), init) 
} 

fun WarpScript.forget(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("FORGET", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.forget(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("FORGET", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.fromBin(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FROMBIN"), init) 
} 

fun WarpScript.fromBin(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("FROMBIN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.fromBin(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("FROMBIN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.fromBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FROMBITS"), init) 
} 

fun WarpScript.fromBits(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("FROMBITS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.fromBits(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("FROMBITS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.fromHex(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FROMHEX"), init) 
} 

fun WarpScript.fromHex(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("FROMHEX", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.fromHex(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("FROMHEX", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.get(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("GET"), init) 
} 

fun WarpScript.get(index: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to index)
    return initTag(Functions("GET", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.get(index: Long? = null, indexElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to index)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to indexElements)
    return initTag(Functions("GET", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.greaterOrEqual(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">="), init) 
} 

fun WarpScript.greaterOrEqual(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions(">=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.greaterOrEqual(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions(">=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.greaterThan(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">"), init) 
} 

fun WarpScript.greaterThan(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions(">", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.greaterThan(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions(">", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.gzip(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("GZIP"), init) 
} 

fun WarpScript.gzip(input: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("GZIP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.gzip(input: String? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("GZIP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.h(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("h"), init) 
} 

fun WarpScript.h(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("h", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.h(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("h", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.hash(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("HASH"), init) 
} 

fun WarpScript.hash(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("HASH", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.hash(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("HASH", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.hexTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("HEX->"), init) 
} 

fun WarpScript.hexTo(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("HEX->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.hexTo(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("HEX->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.hexToBase64(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("HEXTOB64"), init) 
} 

fun WarpScript.hexToBase64(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("HEXTOB64", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.hexToBase64(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("HEXTOB64", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.hexToBin(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("HEXTOBIN"), init) 
} 

fun WarpScript.hexToBin(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("HEXTOBIN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.hexToBin(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("HEXTOBIN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.humanDuration(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("HUMANDURATION"), init) 
} 

fun WarpScript.humanDuration(timeUnit: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timeUnit)
    return initTag(Functions("HUMANDURATION", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.humanDuration(timeUnit: Long? = null, timeUnitElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timeUnit)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timeUnitElements)
    return initTag(Functions("HUMANDURATION", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.ieeeRemainder(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("IEEEREMAINDER"), init) 
} 

fun WarpScript.ieeeRemainder(f1: Number, f2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to f1, 2 to f2)
    return initTag(Functions("IEEEREMAINDER", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ieeeRemainder(f1: Number? = null, f1Elements: Element.() -> Unit = emptyLambda, 
            f2: Number? = null, f2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to f1, 2 to f2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to f1Elements, 2 to f2Elements)
    return initTag(Functions("IEEEREMAINDER", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.intersection(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("INTERSECTION"), init) 
} 

fun WarpScript.isNotANumber(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ISNaN"), init) 
} 

fun WarpScript.isNotANumber(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ISNaN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.isNotANumber(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ISNaN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.isNullWarp10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ISNULL"), init) 
} 

fun WarpScript.isNullWarp10(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ISNULL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.isNullWarp10(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ISNULL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.iso8601(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ISO8601"), init) 
} 

fun WarpScript.iso8601(timestamp: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    return initTag(Functions("ISO8601", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.iso8601(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements)
    return initTag(Functions("ISO8601", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.join(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("JOIN"), init) 
} 

fun WarpScript.join(separator: String, elementsToLoad: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to separator, 2 to elementsToLoad)
    return initTag(Functions("JOIN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.join(separator: String? = null, separatorElements: Element.() -> Unit = emptyLambda, 
            elementsToLoad: Long? = null, elementsToLoadElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to separator, 2 to elementsToLoad)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to separatorElements, 2 to elementsToLoadElements)
    return initTag(Functions("JOIN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.jsonTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("JSON->"), init) 
} 

fun WarpScript.jsonTo(jsonString: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to jsonString)
    return initTag(Functions("JSON->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.jsonTo(jsonString: String? = null, jsonStringElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to jsonString)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to jsonStringElements)
    return initTag(Functions("JSON->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.keyList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("KEYLIST"), init) 
} 

fun WarpScript.keyList(input: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("KEYLIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.keyList(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("KEYLIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.lBounds(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LBOUNDS"), init) 
} 

fun WarpScript.lBounds(a: Number, b: Number, M: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to a, 2 to b, 3 to M)
    return initTag(Functions("LBOUNDS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.lBounds(a: Number? = null, aElements: Element.() -> Unit = emptyLambda, 
            b: Number? = null, bElements: Element.() -> Unit = emptyLambda, 
            M: Long? = null, MElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to a, 2 to b, 3 to M)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to aElements, 2 to bElements, 3 to MElements)
    return initTag(Functions("LBOUNDS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.lSort(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LSORT"), init) 
} 

fun WarpScript.lSort(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("LSORT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.lSort(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("LSORT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.leftShiftBitsOfALong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<<"), init) 
} 

fun WarpScript.leftShiftBitsOfALong(number: Long, shiftedBits: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    return initTag(Functions("<<", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.leftShiftBitsOfALong(number: Long? = null, numberElements: Element.() -> Unit = emptyLambda, 
            shiftedBits: Long? = null, shiftedBitsElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberElements, 2 to shiftedBitsElements)
    return initTag(Functions("<<", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.listTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LIST->"), init) 
} 

fun WarpScript.listTo(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("LIST->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.listTo(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("LIST->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.log(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LOG"), init) 
} 

fun WarpScript.log(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("LOG", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.log(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("LOG", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.log10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LOG10"), init) 
} 

fun WarpScript.log10(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("LOG10", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.log10(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("LOG10", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.longBitsToDouble(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DOUBLEBITS->"), init) 
} 

fun WarpScript.longBitsToDouble(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("DOUBLEBITS->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.longBitsToDouble(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("DOUBLEBITS->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.longBitsToFloatToDouble(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FLOATBITS->"), init) 
} 

fun WarpScript.longBitsToFloatToDouble(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("FLOATBITS->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.longBitsToFloatToDouble(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("FLOATBITS->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.lowerOrEqual(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<="), init) 
} 

fun WarpScript.lowerOrEqual(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("<=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.lowerOrEqual(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("<=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.lowerThan(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<"), init) 
} 

fun WarpScript.lowerThan(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("<", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.lowerThan(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("<", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.m(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("m"), init) 
} 

fun WarpScript.m(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("m", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.m(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("m", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mSort(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MSORT"), init) 
} 

fun WarpScript.mSort(input: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("MSORT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mSort(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("MSORT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mapId(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAPID"), init) 
} 

fun WarpScript.mapId(input: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("MAPID", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mapId(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("MAPID", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mapTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAP->"), init) 
} 

fun WarpScript.mapTo(input: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("MAP->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mapTo(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("MAP->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mark(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MARK"), init) 
} 

fun WarpScript.matTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAT->"), init) 
} 

fun WarpScript.match(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MATCH"), init) 
} 

fun WarpScript.match(value: String, regExp: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value, 2 to regExp)
    return initTag(Functions("MATCH", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.match(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            regExp: String? = null, regExpElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value, 2 to regExp)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements, 2 to regExpElements)
    return initTag(Functions("MATCH", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.matcher(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MATCHER"), init) 
} 

fun WarpScript.matcher(regExp: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to regExp)
    return initTag(Functions("MATCHER", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.matcher(regExp: String? = null, regExpElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to regExp)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to regExpElements)
    return initTag(Functions("MATCHER", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.max(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAX"), init) 
} 

fun WarpScript.max(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("MAX", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.max(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("MAX", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.maxLong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAXLONG"), init) 
} 

fun WarpScript.md5(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MD5"), init) 
} 

fun WarpScript.min(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MIN"), init) 
} 

fun WarpScript.min(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("MIN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.min(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("MIN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.minLong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MINLONG"), init) 
} 

fun WarpScript.mod(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("%"), init) 
} 

fun WarpScript.mod(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("%", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mod(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("%", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.ms(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ms"), init) 
} 

fun WarpScript.ms(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ms", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ms(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ms", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.msTU(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MSTU"), init) 
} 

fun WarpScript.msgFail(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MSGFAIL"), init) 
} 

fun WarpScript.msgFail(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("MSGFAIL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.msgFail(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("MSGFAIL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mul(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("*"), init) 
} 

fun WarpScript.mul(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("*", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mul(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("*", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nBounds(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NBOUNDS"), init) 
} 

fun WarpScript.nBounds(mu: Number, sigma: Number, n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to mu, 2 to sigma, 3 to n)
    return initTag(Functions("NBOUNDS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.nBounds(mu: Number? = null, muElements: Element.() -> Unit = emptyLambda, 
            sigma: Number? = null, sigmaElements: Element.() -> Unit = emptyLambda, 
            n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to mu, 2 to sigma, 3 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to muElements, 2 to sigmaElements, 3 to nElements)
    return initTag(Functions("NBOUNDS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nDebugOn(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NDEBUGON"), init) 
} 

fun WarpScript.nDebugOn(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("NDEBUGON", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.nDebugOn(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("NDEBUGON", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nReturn(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NRETURN"), init) 
} 

fun WarpScript.nReturn(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("NRETURN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.nReturn(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("NRETURN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nextAfter(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NEXTAFTER"), init) 
} 

fun WarpScript.nextAfter(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("NEXTAFTER", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.nextAfter(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("NEXTAFTER", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nextUp(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NEXTUP"), init) 
} 

fun WarpScript.nextUp(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("NEXTUP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.nextUp(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("NEXTUP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.noTimings(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NOTIMINGS"), init) 
} 

fun WarpScript.notANumber(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NaN"), init) 
} 

fun WarpScript.notAfter(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NOTAFTER"), init) 
} 

fun WarpScript.notAfter(timestamp: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    return initTag(Functions("NOTAFTER", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.notAfter(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements)
    return initTag(Functions("NOTAFTER", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.notBefore(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NOTBEFORE"), init) 
} 

fun WarpScript.notBefore(timestamp: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    return initTag(Functions("NOTBEFORE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.notBefore(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements)
    return initTag(Functions("NOTBEFORE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.notEqual(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("!="), init) 
} 

fun WarpScript.notEqual(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("!=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.notEqual(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("!=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.notLogical(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("!"), init) 
} 

fun WarpScript.notLogical(value: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("!", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.notLogical(value: Boolean? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("!", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.now(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NOW"), init) 
} 

fun WarpScript.npdf(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NPDF"), init) 
} 

fun WarpScript.npdf(mu: Number, sigma: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to mu, 2 to sigma)
    return initTag(Functions("NPDF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.npdf(mu: Number? = null, muElements: Element.() -> Unit = emptyLambda, 
            sigma: Number? = null, sigmaElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to mu, 2 to sigma)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to muElements, 2 to sigmaElements)
    return initTag(Functions("NPDF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.ns(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ns"), init) 
} 

fun WarpScript.ns(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ns", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ns(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ns", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nullWarp10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NULL"), init) 
} 

fun WarpScript.opBase64to(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("OPB64->"), init) 
} 

fun WarpScript.opBase64to(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("OPB64->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.opBase64to(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("OPB64->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.opBase64toHex(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("OPB64TOHEX"), init) 
} 

fun WarpScript.opBase64toHex(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("OPB64TOHEX", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.opBase64toHex(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("OPB64TOHEX", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.openList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("["), init) 
} 

fun WarpScript.openMacro(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<%"), init) 
} 

fun WarpScript.openMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("{"), init) 
} 

fun WarpScript.or(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("||"), init) 
} 

fun WarpScript.or(p1: Boolean, p2: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("||", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.or(p1: Boolean? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Boolean? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("||", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.orBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("|"), init) 
} 

fun WarpScript.orBitWise(p1: Long, p2: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("|", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.orBitWise(p1: Long? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Long? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("|", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.pack(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PACK"), init) 
} 

fun WarpScript.pack(input: List<Any>, format: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to format)
    return initTag(Functions("PACK", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.pack(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            format: String? = null, formatElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to format)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to formatElements)
    return initTag(Functions("PACK", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.pi(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PI"), init) 
} 

fun WarpScript.pick(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PICK"), init) 
} 

fun WarpScript.pick(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("PICK", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.pick(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("PICK", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.pickleTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PICKLE->"), init) 
} 

fun WarpScript.probability(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PROBABILITY"), init) 
} 

fun WarpScript.probability(valueHistogram: HashMap<Any,Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to valueHistogram)
    return initTag(Functions("PROBABILITY", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.probability(valueHistogram: HashMap<Any,Number>? = null, valueHistogramElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to valueHistogram)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueHistogramElements)
    return initTag(Functions("PROBABILITY", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.ps(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ps"), init) 
} 

fun WarpScript.ps(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ps", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ps(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ps", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.put(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PUT"), init) 
} 

fun WarpScript.put(input: HashMap<Any,Any>, value: Any, key: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to value, 3 to key)
    return initTag(Functions("PUT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.put(input: HashMap<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            key: Any? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to value, 3 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to valueElements, 3 to keyElements)
    return initTag(Functions("PUT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.quaternionConjugate(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QCONJUGATE"), init) 
} 

fun WarpScript.quaternionDivide(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QDIVIDE"), init) 
} 

fun WarpScript.quaternionMultiply(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QMULTIPLY"), init) 
} 

fun WarpScript.quaternionRotate(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QROTATE"), init) 
} 

fun WarpScript.quaternionRotation(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QROTATION"), init) 
} 

fun WarpScript.quaternionTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("Q->"), init) 
} 

fun WarpScript.quaternionTo(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("Q->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.quaternionTo(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("Q->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rExec(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REXEC"), init) 
} 

fun WarpScript.rExec(code: String, url: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to code, 2 to url)
    return initTag(Functions("REXEC", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rExec(code: String? = null, codeElements: Element.() -> Unit = emptyLambda, 
            url: String? = null, urlElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to code, 2 to url)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to codeElements, 2 to urlElements)
    return initTag(Functions("REXEC", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rInt(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RINT"), init) 
} 

fun WarpScript.rInt(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("RINT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rInt(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("RINT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rand(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RAND"), init) 
} 

fun WarpScript.randPDF(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RANDPDF"), init) 
} 

fun WarpScript.randPDF(valueHistogram: HashMap<Any,Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to valueHistogram)
    return initTag(Functions("RANDPDF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.randPDF(valueHistogram: HashMap<Any,Number>? = null, valueHistogramElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to valueHistogram)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueHistogramElements)
    return initTag(Functions("RANDPDF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.range(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RANGE"), init) 
} 

fun WarpScript.range(rangeList: List<Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to rangeList)
    return initTag(Functions("RANGE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.range(rangeList: List<Number>? = null, rangeListElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to rangeList)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to rangeListElements)
    return initTag(Functions("RANGE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.removeList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REMOVE"), init) 
} 

fun WarpScript.removeList(input: List<Any>, index: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to index)
    return initTag(Functions("REMOVE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.removeList(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            index: Any? = null, indexElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to index)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to indexElements)
    return initTag(Functions("REMOVE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.removeMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REMOVE"), init) 
} 

fun WarpScript.removeMap(input: Map<Any,Any>, key: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    return initTag(Functions("REMOVE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.removeMap(input: Map<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            key: Any? = null, keyElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to key)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keyElements)
    return initTag(Functions("REMOVE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.replace(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REPLACE"), init) 
} 

fun WarpScript.replace(input: String, regExp: String, replacement: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to regExp, 3 to replacement)
    return initTag(Functions("REPLACE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.replace(input: String? = null, inputElements: Element.() -> Unit = emptyLambda, 
            regExp: String? = null, regExpElements: Element.() -> Unit = emptyLambda, 
            replacement: String? = null, replacementElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to regExp, 3 to replacement)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to regExpElements, 3 to replacementElements)
    return initTag(Functions("REPLACE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.replaceAll(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REPLACEALL"), init) 
} 

fun WarpScript.replaceAll(input: String, regExp: String, replacement: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to regExp, 3 to replacement)
    return initTag(Functions("REPLACEALL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.replaceAll(input: String? = null, inputElements: Element.() -> Unit = emptyLambda, 
            regExp: String? = null, regExpElements: Element.() -> Unit = emptyLambda, 
            replacement: String? = null, replacementElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to regExp, 3 to replacement)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to regExpElements, 3 to replacementElements)
    return initTag(Functions("REPLACEALL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.reset(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RESET"), init) 
} 

fun WarpScript.reset(depth: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    return initTag(Functions("RESET", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.reset(depth: Long? = null, depthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to depthElements)
    return initTag(Functions("RESET", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.returnWarp10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RETURN"), init) 
} 

fun WarpScript.revBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REVBITS"), init) 
} 

fun WarpScript.revBits(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("REVBITS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.revBits(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("REVBITS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.reverse(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REVERSE"), init) 
} 

fun WarpScript.reverse(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("REVERSE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.reverse(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("REVERSE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">>"), init) 
} 

fun WarpScript.rightShiftBitsOfALong(number: Long, shiftedBits: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    return initTag(Functions(">>", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALong(number: Long? = null, numberElements: Element.() -> Unit = emptyLambda, 
            shiftedBits: Long? = null, shiftedBitsElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberElements, 2 to shiftedBitsElements)
    return initTag(Functions(">>", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALongWithoutSign(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">>>"), init) 
} 

fun WarpScript.rightShiftBitsOfALongWithoutSign(number: Long, shiftedBits: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    return initTag(Functions(">>>", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALongWithoutSign(number: Long? = null, numberElements: Element.() -> Unit = emptyLambda, 
            shiftedBits: Long? = null, shiftedBitsElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberElements, 2 to shiftedBitsElements)
    return initTag(Functions(">>>", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.roll(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ROLL"), init) 
} 

fun WarpScript.roll(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("ROLL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.roll(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("ROLL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rollD(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ROLLD"), init) 
} 

fun WarpScript.rollD(n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    return initTag(Functions("ROLLD", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rollD(n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nElements)
    return initTag(Functions("ROLLD", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rot(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ROT"), init) 
} 

fun WarpScript.rotationToQuaternion(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ROTATIONQ"), init) 
} 

fun WarpScript.rotationToQuaternion(w: Double, x: Double, y: Double, z: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to w, 2 to x, 3 to y, 4 to z)
    return initTag(Functions("ROTATIONQ", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rotationToQuaternion(w: Double? = null, wElements: Element.() -> Unit = emptyLambda, 
            x: Double? = null, xElements: Element.() -> Unit = emptyLambda, 
            y: Double? = null, yElements: Element.() -> Unit = emptyLambda, 
            z: Double? = null, zElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to w, 2 to x, 3 to y, 4 to z)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to wElements, 2 to xElements, 3 to yElements, 4 to zElements)
    return initTag(Functions("ROTATIONQ", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.round(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ROUND"), init) 
} 

fun WarpScript.round(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ROUND", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.round(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ROUND", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rsaDecrypt(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSADECRYPT"), init) 
} 

fun WarpScript.rsaEncrypt(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSAENCRYPT"), init) 
} 

fun WarpScript.rsaGen(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSAGEN"), init) 
} 

fun WarpScript.rsaGen(exponent: String, keyLength: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to exponent, 2 to keyLength)
    return initTag(Functions("RSAGEN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rsaGen(exponent: String? = null, exponentElements: Element.() -> Unit = emptyLambda, 
            keyLength: Long? = null, keyLengthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to exponent, 2 to keyLength)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to exponentElements, 2 to keyLengthElements)
    return initTag(Functions("RSAGEN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rsaPrivate(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSAPRIVATE"), init) 
} 

fun WarpScript.rsaPrivate(parameter: HashMap<String,String>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to parameter)
    return initTag(Functions("RSAPRIVATE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rsaPrivate(parameter: HashMap<String,String>? = null, parameterElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to parameter)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to parameterElements)
    return initTag(Functions("RSAPRIVATE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rsaPublic(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSAPUBLIC"), init) 
} 

fun WarpScript.rsaPublic(parameter: HashMap<String,String>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to parameter)
    return initTag(Functions("RSAPUBLIC", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rsaPublic(parameter: HashMap<String,String>? = null, parameterElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to parameter)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to parameterElements)
    return initTag(Functions("RSAPUBLIC", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rsaSign(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSASIGN"), init) 
} 

fun WarpScript.rsaVerify(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RSAVERIFY"), init) 
} 

fun WarpScript.run(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RUN"), init) 
} 

fun WarpScript.run(name: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to name)
    return initTag(Functions("RUN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.run(name: String? = null, nameElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to name)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to nameElements)
    return initTag(Functions("RUN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.s(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("s"), init) 
} 

fun WarpScript.s(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("s", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.s(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("s", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.sTU(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("STU"), init) 
} 

fun WarpScript.set(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SET"), init) 
} 

fun WarpScript.set(input: List<Any>, elem: Any, index: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to elem, 3 to index)
    return initTag(Functions("SET", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.set(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            elem: Any? = null, elemElements: Element.() -> Unit = emptyLambda, 
            index: Long? = null, indexElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to elem, 3 to index)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to elemElements, 3 to indexElements)
    return initTag(Functions("SET", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.setTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SET->"), init) 
} 

fun WarpScript.sha1(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SHA1"), init) 
} 

fun WarpScript.sha1Hmac(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SHA1HMAC"), init) 
} 

fun WarpScript.sha256(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SHA256"), init) 
} 

fun WarpScript.sha256Hmac(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SHA256HMAC"), init) 
} 

fun WarpScript.sigNum(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SIGNUM"), init) 
} 

fun WarpScript.sigNum(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("SIGNUM", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sigNum(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("SIGNUM", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.sin(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SIN"), init) 
} 

fun WarpScript.sin(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("SIN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sin(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("SIN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.sinh(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SINH"), init) 
} 

fun WarpScript.sinh(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("SINH", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sinh(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("SINH", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.size(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SIZE"), init) 
} 

fun WarpScript.size(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("SIZE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.size(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("SIZE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.snapshot(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SNAPSHOT"), init) 
} 

fun WarpScript.snapshotAll(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SNAPSHOTALL"), init) 
} 

fun WarpScript.snapshotAllToMark(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SNAPSHOTALLTOMARK"), init) 
} 

fun WarpScript.snapshotToMark(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SNAPSHOTTOMARK"), init) 
} 

fun WarpScript.split(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SPLIT"), init) 
} 

fun WarpScript.split(input: String, delimiter: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to delimiter)
    return initTag(Functions("SPLIT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.split(input: String? = null, inputElements: Element.() -> Unit = emptyLambda, 
            delimiter: String? = null, delimiterElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to delimiter)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to delimiterElements)
    return initTag(Functions("SPLIT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.sqrt(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SQRT"), init) 
} 

fun WarpScript.sqrt(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("SQRT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sqrt(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("SQRT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.stackAttribute(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("STACKATTRIBUTE"), init) 
} 

fun WarpScript.stackAttribute(attribute: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to attribute)
    return initTag(Functions("STACKATTRIBUTE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.stackAttribute(attribute: String? = null, attributeElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to attribute)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to attributeElements)
    return initTag(Functions("STACKATTRIBUTE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.stackToList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("STACKTOLIST"), init) 
} 

fun WarpScript.stop(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("STOP"), init) 
} 

fun WarpScript.sub(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("-"), init) 
} 

fun WarpScript.sub(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("-", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sub(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("-", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.subList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SUBLIST"), init) 
} 

fun WarpScript.subList(input: List<Any>, indexes: List<Long>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to indexes)
    return initTag(Functions("SUBLIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.subList(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            indexes: List<Long>? = null, indexesElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to indexes)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to indexesElements)
    return initTag(Functions("SUBLIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.subMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SUBMAP"), init) 
} 

fun WarpScript.subMap(input: Map<Any,Any>, keys: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to keys)
    return initTag(Functions("SUBMAP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.subMap(input: Map<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            keys: List<Any>? = null, keysElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to keys)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to keysElements)
    return initTag(Functions("SUBMAP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.substring(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SUBSTRING"), init) 
} 

fun WarpScript.substring(value: String, startIndex: Long, length: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value, 2 to startIndex, 3 to length)
    return initTag(Functions("SUBSTRING", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.substring(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            startIndex: Long? = null, startIndexElements: Element.() -> Unit = emptyLambda, 
            length: Long? = null, lengthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value, 2 to startIndex, 3 to length)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements, 2 to startIndexElements, 3 to lengthElements)
    return initTag(Functions("SUBSTRING", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.substringStartAt(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SUBSTRING"), init) 
} 

fun WarpScript.substringStartAt(value: String, startIndex: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value, 2 to startIndex)
    return initTag(Functions("SUBSTRING", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.substringStartAt(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            startIndex: Long? = null, startIndexElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value, 2 to startIndex)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements, 2 to startIndexElements)
    return initTag(Functions("SUBSTRING", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.swap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SWAP"), init) 
} 

fun WarpScript.tan(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TAN"), init) 
} 

fun WarpScript.tan(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TAN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.tan(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TAN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.tanh(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TANH"), init) 
} 

fun WarpScript.tanh(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TANH", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.tanh(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TANH", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.template(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TEMPLATE"), init) 
} 

fun WarpScript.template(input: String, template: HashMap<String, Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to template)
    return initTag(Functions("TEMPLATE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.template(input: String? = null, inputElements: Element.() -> Unit = emptyLambda, 
            template: HashMap<String, Any>? = null, templateElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input, 2 to template)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements, 2 to templateElements)
    return initTag(Functions("TEMPLATE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.timings(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TIMINGS"), init) 
} 

fun WarpScript.toBase64(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->B64"), init) 
} 

fun WarpScript.toBase64(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->B64", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toBase64(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->B64", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toBase64Url(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->B64URL"), init) 
} 

fun WarpScript.toBase64Url(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->B64URL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toBase64Url(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->B64URL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toBin(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->BIN"), init) 
} 

fun WarpScript.toBin(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->BIN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toBin(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->BIN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toBoolean(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TOBOOLEAN"), init) 
} 

fun WarpScript.toBoolean(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TOBOOLEAN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toBoolean(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TOBOOLEAN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toBytes(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->BYTES"), init) 
} 

fun WarpScript.toBytes(value: String, charset: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value, 2 to charset)
    return initTag(Functions("->BYTES", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toBytes(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            charset: String? = null, charsetElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value, 2 to charset)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements, 2 to charsetElements)
    return initTag(Functions("->BYTES", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toDegrees(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TODEGREES"), init) 
} 

fun WarpScript.toDegrees(radians: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to radians)
    return initTag(Functions("TODEGREES", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toDegrees(radians: Number? = null, radiansElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to radians)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to radiansElements)
    return initTag(Functions("TODEGREES", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toDouble(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TODOUBLE"), init) 
} 

fun WarpScript.toDouble(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TODOUBLE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toDouble(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TODOUBLE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toHex(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TOHEX"), init) 
} 

fun WarpScript.toHex(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TOHEX", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toHex(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TOHEX", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toJson(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->JSON"), init) 
} 

fun WarpScript.toJson(item: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to item)
    return initTag(Functions("->JSON", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toJson(item: Any? = null, itemElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to item)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to itemElements)
    return initTag(Functions("->JSON", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->LIST"), init) 
} 

fun WarpScript.toList(depth: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    return initTag(Functions("->LIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toList(depth: Long? = null, depthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to depthElements)
    return initTag(Functions("->LIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toLong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TOLONG"), init) 
} 

fun WarpScript.toLong(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TOLONG", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toLong(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TOLONG", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toLower(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TOLOWER"), init) 
} 

fun WarpScript.toLower(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TOLOWER", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toLower(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TOLOWER", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->MAP"), init) 
} 

fun WarpScript.toMap(depth: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    return initTag(Functions("->MAP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toMap(depth: Long? = null, depthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to depth)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to depthElements)
    return initTag(Functions("->MAP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toMat(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->MAT"), init) 
} 

fun WarpScript.toMat(twoDList: List<List<Number>>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to twoDList)
    return initTag(Functions("->MAT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toMat(twoDList: List<List<Number>>? = null, twoDListElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to twoDList)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to twoDListElements)
    return initTag(Functions("->MAT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toOpBase64(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->OPB64"), init) 
} 

fun WarpScript.toOpBase64(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->OPB64", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toOpBase64(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->OPB64", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toPickle(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->PICKLE"), init) 
} 

fun WarpScript.toPickle(pickle: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to pickle)
    return initTag(Functions("->PICKLE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toPickle(pickle: HashMap<Any,Any>? = null, pickleElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to pickle)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to pickleElements)
    return initTag(Functions("->PICKLE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toQuaternion(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->Q"), init) 
} 

fun WarpScript.toQuaternion(w: Double, x: Double, y: Double, z: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to w, 2 to x, 3 to y, 4 to z)
    return initTag(Functions("->Q", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toQuaternion(w: Double? = null, wElements: Element.() -> Unit = emptyLambda, 
            x: Double? = null, xElements: Element.() -> Unit = emptyLambda, 
            y: Double? = null, yElements: Element.() -> Unit = emptyLambda, 
            z: Double? = null, zElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to w, 2 to x, 3 to y, 4 to z)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to wElements, 2 to xElements, 3 to yElements, 4 to zElements)
    return initTag(Functions("->Q", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toRadians(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TORADIANS"), init) 
} 

fun WarpScript.toRadians(degrees: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to degrees)
    return initTag(Functions("TORADIANS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toRadians(degrees: Number? = null, degreesElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to degrees)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to degreesElements)
    return initTag(Functions("TORADIANS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toSet(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->SET"), init) 
} 

fun WarpScript.toSet(value: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->SET", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toSet(value: List<Any>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->SET", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toString(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TOSTRING"), init) 
} 

fun WarpScript.toString(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TOSTRING", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toString(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TOSTRING", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toTimestamp(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TOTIMESTAMP"), init) 
} 

fun WarpScript.toTimestamp(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TOTIMESTAMP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toTimestamp(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TOTIMESTAMP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toTsElements(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->TSELEMENTS"), init) 
} 

fun WarpScript.toTsElements(timestamp: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    return initTag(Functions("->TSELEMENTS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toTsElements(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements)
    return initTag(Functions("->TSELEMENTS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toTsElementsWithTimeZone(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->TSELEMENTS"), init) 
} 

fun WarpScript.toTsElementsWithTimeZone(timestamp: Long, timeZone: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone)
    return initTag(Functions("->TSELEMENTS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toTsElementsWithTimeZone(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            timeZone: String? = null, timeZoneElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to timeZoneElements)
    return initTag(Functions("->TSELEMENTS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toV(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->V"), init) 
} 

fun WarpScript.toV(value: List<Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->V", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toV(value: List<Number>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->V", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toVector(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->VEC"), init) 
} 

fun WarpScript.toVector(value: List<Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->VEC", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toVector(value: List<Number>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->VEC", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toZOrderCurve(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->Z"), init) 
} 

fun WarpScript.toZOrderCurve(parameter: List<Long>, bitwidth: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to parameter, 2 to bitwidth)
    return initTag(Functions("->Z", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toZOrderCurve(parameter: List<Long>? = null, parameterElements: Element.() -> Unit = emptyLambda, 
            bitwidth: Long? = null, bitwidthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to parameter, 2 to bitwidth)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to parameterElements, 2 to bitwidthElements)
    return initTag(Functions("->Z", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.trim(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TRIM"), init) 
} 

fun WarpScript.trim(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TRIM", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.trim(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TRIM", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.tsElementTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TSELEMENTS->"), init) 
} 

fun WarpScript.tsElementTo(tsElementsList: List<Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to tsElementsList)
    return initTag(Functions("TSELEMENTS->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.tsElementTo(tsElementsList: List<Number>? = null, tsElementsListElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to tsElementsList)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to tsElementsListElements)
    return initTag(Functions("TSELEMENTS->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.tsElementToWithTimeZone(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TSELEMENTS->"), init) 
} 

fun WarpScript.tsElementToWithTimeZone(tsElementsList: List<Number>, timeZone: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to tsElementsList, 2 to timeZone)
    return initTag(Functions("TSELEMENTS->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.tsElementToWithTimeZone(tsElementsList: List<Number>? = null, tsElementsListElements: Element.() -> Unit = emptyLambda, 
            timeZone: String? = null, timeZoneElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to tsElementsList, 2 to timeZone)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to tsElementsListElements, 2 to timeZoneElements)
    return initTag(Functions("TSELEMENTS->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.tuUpper(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TOUPPER"), init) 
} 

fun WarpScript.tuUpper(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TOUPPER", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.tuUpper(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TOUPPER", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.typeOf(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TYPEOF"), init) 
} 

fun WarpScript.typeOf(element: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to element)
    return initTag(Functions("TYPEOF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.typeOf(element: Any? = null, elementElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to element)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to elementElements)
    return initTag(Functions("TYPEOF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.udf(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UDF"), init) 
} 

fun WarpScript.udf(className: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to className)
    return initTag(Functions("UDF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.udf(className: String? = null, classNameElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to className)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to classNameElements)
    return initTag(Functions("UDF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unGzip(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNGZIP"), init) 
} 

fun WarpScript.unList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNLIST"), init) 
} 

fun WarpScript.unList(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("UNLIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unList(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("UNLIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unMap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNMAP"), init) 
} 

fun WarpScript.unMap(input: Map<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("UNMAP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unMap(input: Map<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("UNMAP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unPack(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNPACK"), init) 
} 

fun WarpScript.unPack(format: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to format)
    return initTag(Functions("UNPACK", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unPack(format: String? = null, formatElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to format)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to formatElements)
    return initTag(Functions("UNPACK", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unaryComplementBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("~"), init) 
} 

fun WarpScript.unaryComplementBitWise(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("~", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unaryComplementBitWise(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("~", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.union(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNION"), init) 
} 

fun WarpScript.unique(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UNIQUE"), init) 
} 

fun WarpScript.unique(input: List<Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("UNIQUE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unique(input: List<Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("UNIQUE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.urlDecode(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("URLDECODE"), init) 
} 

fun WarpScript.urlDecode(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("URLDECODE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.urlDecode(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("URLDECODE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.urlEncode(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("URLENCODE"), init) 
} 

fun WarpScript.urlEncode(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("URLENCODE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.urlEncode(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("URLENCODE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.us(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("us"), init) 
} 

fun WarpScript.us(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("us", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.us(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("us", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.uuid(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("UUID"), init) 
} 

fun WarpScript.vTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("V->"), init) 
} 

fun WarpScript.valueList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("VALUELIST"), init) 
} 

fun WarpScript.valueList(input: Map<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    return initTag(Functions("VALUELIST", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.valueList(input: Map<Any,Any>? = null, inputElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to input)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to inputElements)
    return initTag(Functions("VALUELIST", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.vectorTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("VEC->"), init) 
} 

fun WarpScript.w(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("w"), init) 
} 

fun WarpScript.w(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("w", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.w(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("w", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.xorBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("^"), init) 
} 

fun WarpScript.xorBitWise(p1: Long, p2: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("^", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.xorBitWise(p1: Long? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Long? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("^", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.zOrderCurveTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("Z->"), init) 
} 

fun WarpScript.zOrderCurveTo(numberOfComponents: Long, bitWidth: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to numberOfComponents, 2 to bitWidth)
    return initTag(Functions("Z->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.zOrderCurveTo(numberOfComponents: Long? = null, numberOfComponentsElements: Element.() -> Unit = emptyLambda, 
            bitWidth: Long? = null, bitWidthElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to numberOfComponents, 2 to bitWidth)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberOfComponentsElements, 2 to bitWidthElements)
    return initTag(Functions("Z->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.zip(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ZIP"), init) 
} 

fun WarpScript.zip(value: List<List<Any>>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ZIP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.zip(value: List<List<Any>>? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ZIP", data, elements, this, emptyLambda), init) 
} 

