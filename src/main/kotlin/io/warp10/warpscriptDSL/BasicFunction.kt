package io.warp10.warpscriptDSL
 
// 
// WarpScript KOTLINDSL
// @author aurrelhebert 
// @license apache 2.0 
// 
 
// Autogenerated code

fun WarpScript.add(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+"), init) 
} 

fun WarpScript.add(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("+", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.add(p1: Any, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("+", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToCloneList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+"), init) 
} 

fun WarpScript.addToCloneList(p1: List<Any>, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("+", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToCloneList(p1: List<Any>, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("+", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToExistingList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+!"), init) 
} 

fun WarpScript.addToExistingList(p1: List<Any>, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("+!", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToExistingList(p1: List<Any>, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("+!", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToExistingListFromStack(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+!"), init) 
} 

fun WarpScript.addToExistingListFromStack(p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(2 to p2)
    return initTag(Functions("+!", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToExistingListFromStack(p2: Any, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(2 to p2Elements)
    return initTag(Functions("+!", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToStackElement(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+"), init) 
} 

fun WarpScript.addToStackElement(p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(2 to p2)
    return initTag(Functions("+", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToStackElement(p2: Any, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(2 to p2Elements)
    return initTag(Functions("+", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.and(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("&&"), init) 
} 

fun WarpScript.and(p1: Boolean, p2: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("&&", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.and(p1: Boolean, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Boolean, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("&&", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.andBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("&"), init) 
} 

fun WarpScript.andBitWise(p1: Long, p2: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("&", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.andBitWise(p1: Long, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Long, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("&", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.div(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("/"), init) 
} 

fun WarpScript.div(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("/", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.div(p1: Number, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("/", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.doubleToBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->DOUBLEBITS"), init) 
} 

fun WarpScript.doubleToBits(p1: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1)
    return initTag(Functions("->DOUBLEBITS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.doubleToBits(p1: Double, p1Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements)
    return initTag(Functions("->DOUBLEBITS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.doubleToFloatToBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->FLOATBITS"), init) 
} 

fun WarpScript.doubleToFloatToBits(p1: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1)
    return initTag(Functions("->FLOATBITS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.doubleToFloatToBits(p1: Double, p1Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements)
    return initTag(Functions("->FLOATBITS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.drop(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DROP"), init) 
} 

fun WarpScript.equal(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("=="), init) 
} 

fun WarpScript.equal(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("==", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.equal(p1: Any, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("==", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.equalWithToleranceFactor(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("~="), init) 
} 

fun WarpScript.equalWithToleranceFactor(p1: Number, p2: Number, lambda: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2, 3 to lambda)
    return initTag(Functions("~=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.equalWithToleranceFactor(p1: Number, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number, p2Elements: Element.() -> Unit = emptyLambda, 
            lambda: Number, lambdaElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2, 3 to lambda)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements, 3 to lambdaElements)
    return initTag(Functions("~=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.eulerConstant(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("e"), init) 
} 

fun WarpScript.exp(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("**"), init) 
} 

fun WarpScript.exp(base: Number, power: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to base, 2 to power)
    return initTag(Functions("**", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.exp(base: Number, baseElements: Element.() -> Unit = emptyLambda, 
            power: Number, powerElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to base, 2 to power)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to baseElements, 2 to powerElements)
    return initTag(Functions("**", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.greaterOrEqual(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">="), init) 
} 

fun WarpScript.greaterOrEqual(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions(">=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.greaterOrEqual(p1: Any, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions(">=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.greaterThan(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">"), init) 
} 

fun WarpScript.greaterThan(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions(">", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.greaterThan(p1: Any, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions(">", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.leftShiftBitsOfALong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<<"), init) 
} 

fun WarpScript.leftShiftBitsOfALong(number: Long, shiftedBits: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to number, 2 to shiftedBits)
    return initTag(Functions("<<", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.leftShiftBitsOfALong(number: Long, numberElements: Element.() -> Unit = emptyLambda, 
            shiftedBits: Long, shiftedBitsElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to number, 2 to shiftedBits)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberElements, 2 to shiftedBitsElements)
    return initTag(Functions("<<", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.lowerOrEqual(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<="), init) 
} 

fun WarpScript.lowerOrEqual(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("<=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.lowerOrEqual(p1: Any, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("<=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.lowerThan(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<"), init) 
} 

fun WarpScript.lowerThan(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("<", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.lowerThan(p1: Any, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("<", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.maxLong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAXLONG"), init) 
} 

fun WarpScript.minLong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MINLONG"), init) 
} 

fun WarpScript.mod(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("%"), init) 
} 

fun WarpScript.mod(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("%", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mod(p1: Number, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("%", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mul(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("*"), init) 
} 

fun WarpScript.mul(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("*", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mul(p1: Number, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("*", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.notANumber(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NaN"), init) 
} 

fun WarpScript.notEqual(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("!="), init) 
} 

fun WarpScript.notEqual(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("!=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.notEqual(p1: Any, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("!=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.notLogical(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("!"), init) 
} 

fun WarpScript.notLogical(p1: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1)
    return initTag(Functions("!", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.notLogical(p1: Boolean, p1Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements)
    return initTag(Functions("!", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.now(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NOW"), init) 
} 

fun WarpScript.nullWarp10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NULL"), init) 
} 

fun WarpScript.or(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("||"), init) 
} 

fun WarpScript.or(p1: Boolean, p2: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("||", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.or(p1: Boolean, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Boolean, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("||", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.orBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("|"), init) 
} 

fun WarpScript.orBitWise(p1: Long, p2: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("|", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.orBitWise(p1: Long, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Long, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("|", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.pi(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PI"), init) 
} 

fun WarpScript.rightShiftBitsOfALong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">>"), init) 
} 

fun WarpScript.rightShiftBitsOfALong(number: Long, shiftedBits: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to number, 2 to shiftedBits)
    return initTag(Functions(">>", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALong(number: Long, numberElements: Element.() -> Unit = emptyLambda, 
            shiftedBits: Long, shiftedBitsElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to number, 2 to shiftedBits)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberElements, 2 to shiftedBitsElements)
    return initTag(Functions(">>", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALongWithoutSign(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">>>"), init) 
} 

fun WarpScript.rightShiftBitsOfALongWithoutSign(number: Long, shiftedBits: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to number, 2 to shiftedBits)
    return initTag(Functions(">>>", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALongWithoutSign(number: Long, numberElements: Element.() -> Unit = emptyLambda, 
            shiftedBits: Long, shiftedBitsElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to number, 2 to shiftedBits)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberElements, 2 to shiftedBitsElements)
    return initTag(Functions(">>>", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.sub(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("-"), init) 
} 

fun WarpScript.sub(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("-", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sub(p1: Number, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("-", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.swap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SWAP"), init) 
} 

fun WarpScript.unaryComplementBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("~"), init) 
} 

fun WarpScript.unaryComplementBitWise(p1: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1)
    return initTag(Functions("~", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unaryComplementBitWise(p1: Long, p1Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements)
    return initTag(Functions("~", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.xorBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("^"), init) 
} 

fun WarpScript.xorBitWise(p1: Long, p2: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    return initTag(Functions("^", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.xorBitWise(p1: Long, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Long, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("^", data, elements, this, emptyLambda), init) 
} 

