package io.warp10.warpscriptDSL
 
// 
// WarpScript KOTLINDSL
// @author aurrelhebert 
// @license apache 2.0 
// 
 
// Autogenerated code

fun WarpScript.JSONto(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("JSON->"), init) 
} 

fun WarpScript.JSONto(jsonString: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to jsonString)
    return initTag(Functions("JSON->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.JSONto(jsonString: String? = null, jsonStringElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to jsonString)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to jsonStringElements)
    return initTag(Functions("JSON->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.abs(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ABS"), init) 
} 

fun WarpScript.abs(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ABS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.abs(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ABS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.acos(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ACOS"), init) 
} 

fun WarpScript.acos(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ACOS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.acos(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ACOS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.add(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+"), init) 
} 

fun WarpScript.add(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("+", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.add(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("+", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addDays(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ADDDAYS"), init) 
} 

fun WarpScript.addDays(timestamp: Long, NumberOfDaysToAdd: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to NumberOfDaysToAdd)
    return initTag(Functions("ADDDAYS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addDays(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            NumberOfDaysToAdd: Long? = null, NumberOfDaysToAddElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to NumberOfDaysToAdd)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to NumberOfDaysToAddElements)
    return initTag(Functions("ADDDAYS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addDaysWithTimeZone(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ADDDAYS"), init) 
} 

fun WarpScript.addDaysWithTimeZone(timestamp: Long, timeZone: String, NumberOfDaysToAdd: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone, 3 to NumberOfDaysToAdd)
    return initTag(Functions("ADDDAYS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addDaysWithTimeZone(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            timeZone: String? = null, timeZoneElements: Element.() -> Unit = emptyLambda, 
            NumberOfDaysToAdd: Long? = null, NumberOfDaysToAddElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone, 3 to NumberOfDaysToAdd)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to timeZoneElements, 3 to NumberOfDaysToAddElements)
    return initTag(Functions("ADDDAYS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addMonths(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ADDMONTHS"), init) 
} 

fun WarpScript.addMonths(timestamp: Long, NumberOfMonthsToAdd: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to NumberOfMonthsToAdd)
    return initTag(Functions("ADDMONTHS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addMonths(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            NumberOfMonthsToAdd: Long? = null, NumberOfMonthsToAddElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to NumberOfMonthsToAdd)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to NumberOfMonthsToAddElements)
    return initTag(Functions("ADDMONTHS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addMonthsWithTimeZone(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ADDMONTHS"), init) 
} 

fun WarpScript.addMonthsWithTimeZone(timestamp: Long, timeZone: String, NumberOfMonthsToAdd: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone, 3 to NumberOfMonthsToAdd)
    return initTag(Functions("ADDMONTHS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addMonthsWithTimeZone(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            timeZone: String? = null, timeZoneElements: Element.() -> Unit = emptyLambda, 
            NumberOfMonthsToAdd: Long? = null, NumberOfMonthsToAddElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone, 3 to NumberOfMonthsToAdd)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to timeZoneElements, 3 to NumberOfMonthsToAddElements)
    return initTag(Functions("ADDMONTHS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToCloneList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+"), init) 
} 

fun WarpScript.addToCloneList(p1: List<Any>, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("+", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToCloneList(p1: List<Any>? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("+", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToExistingList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+!"), init) 
} 

fun WarpScript.addToExistingList(p1: List<Any>, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("+!", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToExistingList(p1: List<Any>? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("+!", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToExistingListFromStack(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+!"), init) 
} 

fun WarpScript.addToExistingListFromStack(element: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(2 to element)
    return initTag(Functions("+!", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToExistingListFromStack(element: Any? = null, elementElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(2 to element)
    val elements = hashMapOf<Number, Element.() -> Unit>(2 to elementElements)
    return initTag(Functions("+!", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToStackElement(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+"), init) 
} 

fun WarpScript.addToStackElement(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(2 to value)
    return initTag(Functions("+", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToStackElement(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(2 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(2 to valueElements)
    return initTag(Functions("+", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addYears(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ADDYEARS"), init) 
} 

fun WarpScript.addYears(timestamp: Long, NumberOfYearsToAdd: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to NumberOfYearsToAdd)
    return initTag(Functions("ADDYEARS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addYears(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            NumberOfYearsToAdd: Long? = null, NumberOfYearsToAddElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to NumberOfYearsToAdd)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to NumberOfYearsToAddElements)
    return initTag(Functions("ADDYEARS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addYearsWithTimeZone(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ADDYEARS"), init) 
} 

fun WarpScript.addYearsWithTimeZone(timestamp: Long, timeZone: String, NumberOfYearsToAdd: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone, 3 to NumberOfYearsToAdd)
    return initTag(Functions("ADDYEARS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addYearsWithTimeZone(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            timeZone: String? = null, timeZoneElements: Element.() -> Unit = emptyLambda, 
            NumberOfYearsToAdd: Long? = null, NumberOfYearsToAddElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone, 3 to NumberOfYearsToAdd)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to timeZoneElements, 3 to NumberOfYearsToAddElements)
    return initTag(Functions("ADDYEARS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.ago(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("AGO"), init) 
} 

fun WarpScript.ago(duration: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to duration)
    return initTag(Functions("AGO", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ago(duration: Long? = null, durationElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to duration)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to durationElements)
    return initTag(Functions("AGO", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.and(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("&&"), init) 
} 

fun WarpScript.and(p1: Boolean, p2: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("&&", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.and(p1: Boolean? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Boolean? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("&&", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.andBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("&"), init) 
} 

fun WarpScript.andBitWise(p1: Long, p2: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("&", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.andBitWise(p1: Long? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Long? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("&", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.asin(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ASIN"), init) 
} 

fun WarpScript.asin(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ASIN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.asin(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ASIN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.atan(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ATAN"), init) 
} 

fun WarpScript.atan(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ATAN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.atan(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ATAN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.bitCount(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BITCOUNT"), init) 
} 

fun WarpScript.bitGet(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BITGET"), init) 
} 

fun WarpScript.bitGet(index: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to index)
    return initTag(Functions("BITGET", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.bitGet(index: Long? = null, indexElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to index)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to indexElements)
    return initTag(Functions("BITGET", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.bitsToBytes(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BITSTOBYTES"), init) 
} 

fun WarpScript.bytesToBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("BYTESTOBITS"), init) 
} 

fun WarpScript.ceil(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CEIL"), init) 
} 

fun WarpScript.ceil(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("CEIL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ceil(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("CEIL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.copySign(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COPYSIGN"), init) 
} 

fun WarpScript.copySign(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("COPYSIGN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.copySign(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("COPYSIGN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.cos(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COS"), init) 
} 

fun WarpScript.cos(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("COS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.cos(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("COS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.cosh(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COSH"), init) 
} 

fun WarpScript.cosh(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("COSH", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.cosh(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("COSH", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.counter(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COUNTER"), init) 
} 

fun WarpScript.counterDelta(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COUNTERDELTA"), init) 
} 

fun WarpScript.counterDelta(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("COUNTERDELTA", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.counterDelta(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("COUNTERDELTA", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.counterValue(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COUNTERVALUE"), init) 
} 

fun WarpScript.cubicRoot(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CBRT"), init) 
} 

fun WarpScript.cubicRoot(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("CBRT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.cubicRoot(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("CBRT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.d(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("d"), init) 
} 

fun WarpScript.d(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("d", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.d(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("d", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.div(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("/"), init) 
} 

fun WarpScript.div(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("/", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.div(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("/", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.doubleToBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->DOUBLEBITS"), init) 
} 

fun WarpScript.doubleToBits(value: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->DOUBLEBITS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.doubleToBits(value: Double? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->DOUBLEBITS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.doubleToFloatToBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->FLOATBITS"), init) 
} 

fun WarpScript.doubleToFloatToBits(value: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->FLOATBITS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.doubleToFloatToBits(value: Double? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->FLOATBITS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.drop(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DROP"), init) 
} 

fun WarpScript.duration(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DURATION"), init) 
} 

fun WarpScript.duration(ISO8601Duration: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to ISO8601Duration)
    return initTag(Functions("DURATION", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.duration(ISO8601Duration: String? = null, ISO8601DurationElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to ISO8601Duration)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to ISO8601DurationElements)
    return initTag(Functions("DURATION", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.equal(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("=="), init) 
} 

fun WarpScript.equal(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("==", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.equal(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("==", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.equalWithToleranceFactor(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("~="), init) 
} 

fun WarpScript.equalWithToleranceFactor(p1: Number, p2: Number, lambda: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2, 3 to lambda)
    return initTag(Functions("~=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.equalWithToleranceFactor(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            lambda: Number? = null, lambdaElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2, 3 to lambda)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements, 3 to lambdaElements)
    return initTag(Functions("~=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.eulerConstant(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("e"), init) 
} 

fun WarpScript.eulerNumber(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("EXP"), init) 
} 

fun WarpScript.eulerNumber(power: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to power)
    return initTag(Functions("EXP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.eulerNumber(power: Long? = null, powerElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to power)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to powerElements)
    return initTag(Functions("EXP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.exp(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("**"), init) 
} 

fun WarpScript.exp(base: Number, power: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to base, 2 to power)
    return initTag(Functions("**", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.exp(base: Number? = null, baseElements: Element.() -> Unit = emptyLambda, 
            power: Number? = null, powerElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to base, 2 to power)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to baseElements, 2 to powerElements)
    return initTag(Functions("**", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.floor(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FLOOR"), init) 
} 

fun WarpScript.floor(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("FLOOR", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.floor(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("FLOOR", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.greaterOrEqual(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">="), init) 
} 

fun WarpScript.greaterOrEqual(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions(">=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.greaterOrEqual(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions(">=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.greaterThan(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">"), init) 
} 

fun WarpScript.greaterThan(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions(">", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.greaterThan(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions(">", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.h(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("h"), init) 
} 

fun WarpScript.h(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("h", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.h(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("h", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.humanDuration(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("HUMANDURATION"), init) 
} 

fun WarpScript.humanDuration(timeUnit: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timeUnit)
    return initTag(Functions("HUMANDURATION", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.humanDuration(timeUnit: Long? = null, timeUnitElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timeUnit)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timeUnitElements)
    return initTag(Functions("HUMANDURATION", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.ieeeRemainder(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("IEEEREMAINDER"), init) 
} 

fun WarpScript.ieeeRemainder(f1: Number, f2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to f1, 2 to f2)
    return initTag(Functions("IEEEREMAINDER", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ieeeRemainder(f1: Number? = null, f1Elements: Element.() -> Unit = emptyLambda, 
            f2: Number? = null, f2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to f1, 2 to f2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to f1Elements, 2 to f2Elements)
    return initTag(Functions("IEEEREMAINDER", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.isNotANumber(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ISNaN"), init) 
} 

fun WarpScript.isNotANumber(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ISNaN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.isNotANumber(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ISNaN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.isNullWarp10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ISNULL"), init) 
} 

fun WarpScript.isNullWarp10(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ISNULL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.isNullWarp10(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ISNULL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.iso8601(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ISO8601"), init) 
} 

fun WarpScript.iso8601(timestamp: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    return initTag(Functions("ISO8601", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.iso8601(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements)
    return initTag(Functions("ISO8601", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.lBounds(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LBOUNDS"), init) 
} 

fun WarpScript.lBounds(a: Number, b: Number, M: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to a, 2 to b, 3 to M)
    return initTag(Functions("LBOUNDS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.lBounds(a: Number? = null, aElements: Element.() -> Unit = emptyLambda, 
            b: Number? = null, bElements: Element.() -> Unit = emptyLambda, 
            M: Long? = null, MElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to a, 2 to b, 3 to M)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to aElements, 2 to bElements, 3 to MElements)
    return initTag(Functions("LBOUNDS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.leftShiftBitsOfALong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<<"), init) 
} 

fun WarpScript.leftShiftBitsOfALong(number: Long, shiftedBits: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    return initTag(Functions("<<", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.leftShiftBitsOfALong(number: Long? = null, numberElements: Element.() -> Unit = emptyLambda, 
            shiftedBits: Long? = null, shiftedBitsElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberElements, 2 to shiftedBitsElements)
    return initTag(Functions("<<", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.log(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LOG"), init) 
} 

fun WarpScript.log(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("LOG", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.log(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("LOG", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.log10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LOG10"), init) 
} 

fun WarpScript.log10(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("LOG10", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.log10(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("LOG10", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.longBitsToDouble(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DOUBLEBITS->"), init) 
} 

fun WarpScript.longBitsToDouble(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("DOUBLEBITS->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.longBitsToDouble(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("DOUBLEBITS->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.longBitsToFloatToDouble(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FLOATBITS->"), init) 
} 

fun WarpScript.longBitsToFloatToDouble(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("FLOATBITS->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.longBitsToFloatToDouble(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("FLOATBITS->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.lowerOrEqual(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<="), init) 
} 

fun WarpScript.lowerOrEqual(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("<=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.lowerOrEqual(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("<=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.lowerThan(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<"), init) 
} 

fun WarpScript.lowerThan(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("<", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.lowerThan(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("<", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.m(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("m"), init) 
} 

fun WarpScript.m(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("m", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.m(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("m", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.max(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAX"), init) 
} 

fun WarpScript.max(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("MAX", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.max(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("MAX", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.maxLong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAXLONG"), init) 
} 

fun WarpScript.min(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MIN"), init) 
} 

fun WarpScript.min(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("MIN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.min(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("MIN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.minLong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MINLONG"), init) 
} 

fun WarpScript.mod(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("%"), init) 
} 

fun WarpScript.mod(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("%", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mod(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("%", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.ms(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ms"), init) 
} 

fun WarpScript.ms(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ms", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ms(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ms", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.msTU(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MSTU"), init) 
} 

fun WarpScript.mul(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("*"), init) 
} 

fun WarpScript.mul(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("*", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mul(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("*", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nBounds(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NBOUNDS"), init) 
} 

fun WarpScript.nBounds(mu: Number, sigma: Number, n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to mu, 2 to sigma, 3 to n)
    return initTag(Functions("NBOUNDS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.nBounds(mu: Number? = null, muElements: Element.() -> Unit = emptyLambda, 
            sigma: Number? = null, sigmaElements: Element.() -> Unit = emptyLambda, 
            n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to mu, 2 to sigma, 3 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to muElements, 2 to sigmaElements, 3 to nElements)
    return initTag(Functions("NBOUNDS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nextAfter(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NEXTAFTER"), init) 
} 

fun WarpScript.nextAfter(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("NEXTAFTER", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.nextAfter(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("NEXTAFTER", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nextUp(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NEXTUP"), init) 
} 

fun WarpScript.nextUp(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("NEXTUP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.nextUp(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("NEXTUP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.notANumber(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NaN"), init) 
} 

fun WarpScript.notAfter(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NOTAFTER"), init) 
} 

fun WarpScript.notAfter(timestamp: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    return initTag(Functions("NOTAFTER", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.notAfter(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements)
    return initTag(Functions("NOTAFTER", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.notBefore(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NOTBEFORE"), init) 
} 

fun WarpScript.notBefore(timestamp: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    return initTag(Functions("NOTBEFORE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.notBefore(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements)
    return initTag(Functions("NOTBEFORE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.notEqual(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("!="), init) 
} 

fun WarpScript.notEqual(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("!=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.notEqual(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("!=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.notLogical(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("!"), init) 
} 

fun WarpScript.notLogical(value: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("!", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.notLogical(value: Boolean? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("!", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.now(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NOW"), init) 
} 

fun WarpScript.npdf(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NPDF"), init) 
} 

fun WarpScript.npdf(mu: Number, sigma: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to mu, 2 to sigma)
    return initTag(Functions("NPDF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.npdf(mu: Number? = null, muElements: Element.() -> Unit = emptyLambda, 
            sigma: Number? = null, sigmaElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to mu, 2 to sigma)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to muElements, 2 to sigmaElements)
    return initTag(Functions("NPDF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.ns(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ns"), init) 
} 

fun WarpScript.ns(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ns", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ns(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ns", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nullWarp10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NULL"), init) 
} 

fun WarpScript.or(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("||"), init) 
} 

fun WarpScript.or(p1: Boolean, p2: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("||", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.or(p1: Boolean? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Boolean? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("||", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.orBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("|"), init) 
} 

fun WarpScript.orBitWise(p1: Long, p2: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("|", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.orBitWise(p1: Long? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Long? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("|", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.pi(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PI"), init) 
} 

fun WarpScript.pickleTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PICKLE->"), init) 
} 

fun WarpScript.probability(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PROBABILITY"), init) 
} 

fun WarpScript.probability(valueHistogram: HashMap<Any,Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to valueHistogram)
    return initTag(Functions("PROBABILITY", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.probability(valueHistogram: HashMap<Any,Number>? = null, valueHistogramElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to valueHistogram)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueHistogramElements)
    return initTag(Functions("PROBABILITY", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.ps(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ps"), init) 
} 

fun WarpScript.ps(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ps", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ps(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ps", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.quaternionConjugate(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QCONJUGATE"), init) 
} 

fun WarpScript.quaternionDivide(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QDIVIDE"), init) 
} 

fun WarpScript.quaternionMultiply(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QMULTIPLY"), init) 
} 

fun WarpScript.quaternionRotate(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QROTATE"), init) 
} 

fun WarpScript.quaternionRotation(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("QROTATION"), init) 
} 

fun WarpScript.quaternionTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("Q->"), init) 
} 

fun WarpScript.quaternionTo(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("Q->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.quaternionTo(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("Q->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rInt(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RINT"), init) 
} 

fun WarpScript.rInt(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("RINT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rInt(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("RINT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rand(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RAND"), init) 
} 

fun WarpScript.randPDF(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RANDPDF"), init) 
} 

fun WarpScript.randPDF(valueHistogram: HashMap<Any,Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to valueHistogram)
    return initTag(Functions("RANDPDF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.randPDF(valueHistogram: HashMap<Any,Number>? = null, valueHistogramElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to valueHistogram)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueHistogramElements)
    return initTag(Functions("RANDPDF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.range(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RANGE"), init) 
} 

fun WarpScript.range(rangeList: List<Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to rangeList)
    return initTag(Functions("RANGE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.range(rangeList: List<Number>? = null, rangeListElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to rangeList)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to rangeListElements)
    return initTag(Functions("RANGE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.revBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REVBITS"), init) 
} 

fun WarpScript.revBits(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("REVBITS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.revBits(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("REVBITS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">>"), init) 
} 

fun WarpScript.rightShiftBitsOfALong(number: Long, shiftedBits: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    return initTag(Functions(">>", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALong(number: Long? = null, numberElements: Element.() -> Unit = emptyLambda, 
            shiftedBits: Long? = null, shiftedBitsElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberElements, 2 to shiftedBitsElements)
    return initTag(Functions(">>", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALongWithoutSign(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">>>"), init) 
} 

fun WarpScript.rightShiftBitsOfALongWithoutSign(number: Long, shiftedBits: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    return initTag(Functions(">>>", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALongWithoutSign(number: Long? = null, numberElements: Element.() -> Unit = emptyLambda, 
            shiftedBits: Long? = null, shiftedBitsElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberElements, 2 to shiftedBitsElements)
    return initTag(Functions(">>>", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rotationToQuaternion(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ROTATIONQ"), init) 
} 

fun WarpScript.rotationToQuaternion(w: Double, x: Double, y: Double, z: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to w, 2 to x, 3 to y, 4 to z)
    return initTag(Functions("ROTATIONQ", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rotationToQuaternion(w: Double? = null, wElements: Element.() -> Unit = emptyLambda, 
            x: Double? = null, xElements: Element.() -> Unit = emptyLambda, 
            y: Double? = null, yElements: Element.() -> Unit = emptyLambda, 
            z: Double? = null, zElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to w, 2 to x, 3 to y, 4 to z)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to wElements, 2 to xElements, 3 to yElements, 4 to zElements)
    return initTag(Functions("ROTATIONQ", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.round(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ROUND"), init) 
} 

fun WarpScript.round(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ROUND", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.round(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ROUND", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.s(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("s"), init) 
} 

fun WarpScript.s(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("s", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.s(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("s", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.sTU(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("STU"), init) 
} 

fun WarpScript.sigNum(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SIGNUM"), init) 
} 

fun WarpScript.sigNum(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("SIGNUM", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sigNum(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("SIGNUM", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.sin(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SIN"), init) 
} 

fun WarpScript.sin(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("SIN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sin(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("SIN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.sinh(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SINH"), init) 
} 

fun WarpScript.sinh(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("SINH", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sinh(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("SINH", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.sqrt(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SQRT"), init) 
} 

fun WarpScript.sqrt(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("SQRT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sqrt(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("SQRT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.sub(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("-"), init) 
} 

fun WarpScript.sub(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("-", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sub(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("-", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.swap(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SWAP"), init) 
} 

fun WarpScript.tan(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TAN"), init) 
} 

fun WarpScript.tan(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TAN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.tan(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TAN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.tanh(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TANH"), init) 
} 

fun WarpScript.tanh(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TANH", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.tanh(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TANH", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toBin(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TOBIN"), init) 
} 

fun WarpScript.toBin(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TOBIN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toBin(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TOBIN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toBoolean(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TOBOOLEAN"), init) 
} 

fun WarpScript.toBoolean(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TOBOOLEAN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toBoolean(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TOBOOLEAN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toDegrees(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TODEGREES"), init) 
} 

fun WarpScript.toDegrees(radians: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to radians)
    return initTag(Functions("TODEGREES", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toDegrees(radians: Number? = null, radiansElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to radians)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to radiansElements)
    return initTag(Functions("TODEGREES", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toDouble(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TODOUBLE"), init) 
} 

fun WarpScript.toDouble(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TODOUBLE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toDouble(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TODOUBLE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toJSON(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->JSON"), init) 
} 

fun WarpScript.toJSON(item: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to item)
    return initTag(Functions("->JSON", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toJSON(item: Any? = null, itemElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to item)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to itemElements)
    return initTag(Functions("->JSON", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toLong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TOLONG"), init) 
} 

fun WarpScript.toLong(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TOLONG", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toLong(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TOLONG", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toPickle(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->PICKLE"), init) 
} 

fun WarpScript.toPickle(pickle: HashMap<Any,Any>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to pickle)
    return initTag(Functions("->PICKLE", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toPickle(pickle: HashMap<Any,Any>? = null, pickleElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to pickle)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to pickleElements)
    return initTag(Functions("->PICKLE", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toQuaternion(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->Q"), init) 
} 

fun WarpScript.toQuaternion(w: Double, x: Double, y: Double, z: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to w, 2 to x, 3 to y, 4 to z)
    return initTag(Functions("->Q", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toQuaternion(w: Double? = null, wElements: Element.() -> Unit = emptyLambda, 
            x: Double? = null, xElements: Element.() -> Unit = emptyLambda, 
            y: Double? = null, yElements: Element.() -> Unit = emptyLambda, 
            z: Double? = null, zElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to w, 2 to x, 3 to y, 4 to z)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to wElements, 2 to xElements, 3 to yElements, 4 to zElements)
    return initTag(Functions("->Q", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toRadians(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TORADIANS"), init) 
} 

fun WarpScript.toRadians(degrees: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to degrees)
    return initTag(Functions("TORADIANS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toRadians(degrees: Number? = null, degreesElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to degrees)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to degreesElements)
    return initTag(Functions("TORADIANS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toString(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TOSTRING"), init) 
} 

fun WarpScript.toString(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TOSTRING", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toString(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TOSTRING", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toTimestamp(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TOTIMESTAMP"), init) 
} 

fun WarpScript.toTimestamp(value: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("TOTIMESTAMP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toTimestamp(value: String? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("TOTIMESTAMP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toTsElements(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->TSELEMENTS"), init) 
} 

fun WarpScript.toTsElements(timestamp: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    return initTag(Functions("->TSELEMENTS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toTsElements(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements)
    return initTag(Functions("->TSELEMENTS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.toTsElementsWithTimeZone(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->TSELEMENTS"), init) 
} 

fun WarpScript.toTsElementsWithTimeZone(timestamp: Long, timeZone: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone)
    return initTag(Functions("->TSELEMENTS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.toTsElementsWithTimeZone(timestamp: Long? = null, timestampElements: Element.() -> Unit = emptyLambda, 
            timeZone: String? = null, timeZoneElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to timestamp, 2 to timeZone)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to timestampElements, 2 to timeZoneElements)
    return initTag(Functions("->TSELEMENTS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.tsElementTo(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TSELEMENTS->"), init) 
} 

fun WarpScript.tsElementTo(tsElementsList: List<Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to tsElementsList)
    return initTag(Functions("TSELEMENTS->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.tsElementTo(tsElementsList: List<Number>? = null, tsElementsListElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to tsElementsList)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to tsElementsListElements)
    return initTag(Functions("TSELEMENTS->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.tsElementToWithTimeZone(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("TSELEMENTS->"), init) 
} 

fun WarpScript.tsElementToWithTimeZone(tsElementsList: List<Number>, timeZone: String, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to tsElementsList, 2 to timeZone)
    return initTag(Functions("TSELEMENTS->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.tsElementToWithTimeZone(tsElementsList: List<Number>? = null, tsElementsListElements: Element.() -> Unit = emptyLambda, 
            timeZone: String? = null, timeZoneElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to tsElementsList, 2 to timeZone)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to tsElementsListElements, 2 to timeZoneElements)
    return initTag(Functions("TSELEMENTS->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unaryComplementBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("~"), init) 
} 

fun WarpScript.unaryComplementBitWise(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("~", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unaryComplementBitWise(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("~", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.us(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("us"), init) 
} 

fun WarpScript.us(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("us", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.us(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("us", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.w(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("w"), init) 
} 

fun WarpScript.w(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("w", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.w(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("w", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.xorBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("^"), init) 
} 

fun WarpScript.xorBitWise(p1: Long, p2: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("^", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.xorBitWise(p1: Long? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Long? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("^", data, elements, this, emptyLambda), init) 
} 

