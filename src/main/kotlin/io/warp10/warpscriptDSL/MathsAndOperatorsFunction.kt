package io.warp10.warpscriptDSL
 
// 
// WarpScript KOTLINDSL
// @author aurrelhebert 
// @license apache 2.0 
// 
 
// Autogenerated code
 
fun WarpScript.abs(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ABS"), init) 
} 

fun WarpScript.abs(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ABS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.abs(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ABS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.add(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+"), init) 
} 

fun WarpScript.add(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("+", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.add(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("+", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToCloneList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+"), init) 
} 

fun WarpScript.addToCloneList(p1: List<Any>, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("+", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToCloneList(p1: List<Any>? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("+", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToExistingList(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+!"), init) 
} 

fun WarpScript.addToExistingList(p1: List<Any>, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("+!", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToExistingList(p1: List<Any>? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("+!", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToExistingListFromStack(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+!"), init) 
} 

fun WarpScript.addToExistingListFromStack(element: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(2 to element)
    return initTag(Functions("+!", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToExistingListFromStack(element: Any? = null, elementElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(2 to element)
    val elements = hashMapOf<Number, Element.() -> Unit>(2 to elementElements)
    return initTag(Functions("+!", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.addToStackElement(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("+"), init) 
} 

fun WarpScript.addToStackElement(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(2 to value)
    return initTag(Functions("+", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.addToStackElement(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(2 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(2 to valueElements)
    return initTag(Functions("+", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.and(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("&&"), init) 
} 

fun WarpScript.and(p1: Boolean, p2: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("&&", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.and(p1: Boolean? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Boolean? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("&&", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.andBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("&"), init) 
} 

fun WarpScript.andBitWise(p1: Long, p2: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("&", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.andBitWise(p1: Long? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Long? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("&", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.ceil(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CEIL"), init) 
} 

fun WarpScript.ceil(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("CEIL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ceil(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("CEIL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.copySign(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("COPYSIGN"), init) 
} 

fun WarpScript.copySign(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("COPYSIGN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.copySign(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("COPYSIGN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.cubicRoot(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("CBRT"), init) 
} 

fun WarpScript.cubicRoot(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("CBRT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.cubicRoot(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("CBRT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.div(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("/"), init) 
} 

fun WarpScript.div(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("/", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.div(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("/", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.doubleToBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->DOUBLEBITS"), init) 
} 

fun WarpScript.doubleToBits(value: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->DOUBLEBITS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.doubleToBits(value: Double? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->DOUBLEBITS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.doubleToFloatToBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("->FLOATBITS"), init) 
} 

fun WarpScript.doubleToFloatToBits(value: Double, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("->FLOATBITS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.doubleToFloatToBits(value: Double? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("->FLOATBITS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.equal(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("=="), init) 
} 

fun WarpScript.equal(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("==", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.equal(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("==", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.equalWithToleranceFactor(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("~="), init) 
} 

fun WarpScript.equalWithToleranceFactor(p1: Number, p2: Number, lambda: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2, 3 to lambda)
    return initTag(Functions("~=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.equalWithToleranceFactor(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            lambda: Number? = null, lambdaElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2, 3 to lambda)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements, 3 to lambdaElements)
    return initTag(Functions("~=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.eulerNumber(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("EXP"), init) 
} 

fun WarpScript.eulerNumber(power: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to power)
    return initTag(Functions("EXP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.eulerNumber(power: Long? = null, powerElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to power)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to powerElements)
    return initTag(Functions("EXP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.exp(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("**"), init) 
} 

fun WarpScript.exp(base: Number, power: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to base, 2 to power)
    return initTag(Functions("**", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.exp(base: Number? = null, baseElements: Element.() -> Unit = emptyLambda, 
            power: Number? = null, powerElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to base, 2 to power)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to baseElements, 2 to powerElements)
    return initTag(Functions("**", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.floor(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FLOOR"), init) 
} 

fun WarpScript.floor(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("FLOOR", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.floor(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("FLOOR", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.greaterOrEqual(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">="), init) 
} 

fun WarpScript.greaterOrEqual(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions(">=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.greaterOrEqual(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions(">=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.greaterThan(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">"), init) 
} 

fun WarpScript.greaterThan(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions(">", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.greaterThan(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions(">", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.ieeeRemainder(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("IEEEREMAINDER"), init) 
} 

fun WarpScript.ieeeRemainder(f1: Number, f2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to f1, 2 to f2)
    return initTag(Functions("IEEEREMAINDER", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.ieeeRemainder(f1: Number? = null, f1Elements: Element.() -> Unit = emptyLambda, 
            f2: Number? = null, f2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to f1, 2 to f2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to f1Elements, 2 to f2Elements)
    return initTag(Functions("IEEEREMAINDER", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.isNotANumber(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ISNaN"), init) 
} 

fun WarpScript.isNotANumber(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ISNaN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.isNotANumber(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ISNaN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.isNullWarp10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ISNULL"), init) 
} 

fun WarpScript.isNullWarp10(value: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ISNULL", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.isNullWarp10(value: Any? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ISNULL", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.lBounds(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LBOUNDS"), init) 
} 

fun WarpScript.lBounds(a: Number, b: Number, M: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to a, 2 to b, 3 to M)
    return initTag(Functions("LBOUNDS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.lBounds(a: Number? = null, aElements: Element.() -> Unit = emptyLambda, 
            b: Number? = null, bElements: Element.() -> Unit = emptyLambda, 
            M: Long? = null, MElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to a, 2 to b, 3 to M)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to aElements, 2 to bElements, 3 to MElements)
    return initTag(Functions("LBOUNDS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.leftShiftBitsOfALong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<<"), init) 
} 

fun WarpScript.leftShiftBitsOfALong(number: Long, shiftedBits: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    return initTag(Functions("<<", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.leftShiftBitsOfALong(number: Long? = null, numberElements: Element.() -> Unit = emptyLambda, 
            shiftedBits: Long? = null, shiftedBitsElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberElements, 2 to shiftedBitsElements)
    return initTag(Functions("<<", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.log(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LOG"), init) 
} 

fun WarpScript.log(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("LOG", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.log(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("LOG", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.log10(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("LOG10"), init) 
} 

fun WarpScript.log10(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("LOG10", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.log10(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("LOG10", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.longBitsToDouble(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("DOUBLEBITS->"), init) 
} 

fun WarpScript.longBitsToDouble(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("DOUBLEBITS->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.longBitsToDouble(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("DOUBLEBITS->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.longBitsToFloatToDouble(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("FLOATBITS->"), init) 
} 

fun WarpScript.longBitsToFloatToDouble(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("FLOATBITS->", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.longBitsToFloatToDouble(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("FLOATBITS->", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.lowerOrEqual(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<="), init) 
} 

fun WarpScript.lowerOrEqual(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("<=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.lowerOrEqual(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("<=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.lowerThan(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("<"), init) 
} 

fun WarpScript.lowerThan(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("<", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.lowerThan(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("<", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.max(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MAX"), init) 
} 

fun WarpScript.max(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("MAX", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.max(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("MAX", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.min(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("MIN"), init) 
} 

fun WarpScript.min(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("MIN", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.min(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("MIN", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mod(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("%"), init) 
} 

fun WarpScript.mod(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("%", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mod(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("%", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.mul(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("*"), init) 
} 

fun WarpScript.mul(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("*", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.mul(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("*", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nBounds(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NBOUNDS"), init) 
} 

fun WarpScript.nBounds(mu: Number, sigma: Number, n: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to mu, 2 to sigma, 3 to n)
    return initTag(Functions("NBOUNDS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.nBounds(mu: Number? = null, muElements: Element.() -> Unit = emptyLambda, 
            sigma: Number? = null, sigmaElements: Element.() -> Unit = emptyLambda, 
            n: Long? = null, nElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to mu, 2 to sigma, 3 to n)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to muElements, 2 to sigmaElements, 3 to nElements)
    return initTag(Functions("NBOUNDS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nextAfter(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NEXTAFTER"), init) 
} 

fun WarpScript.nextAfter(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("NEXTAFTER", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.nextAfter(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("NEXTAFTER", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.nextUp(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NEXTUP"), init) 
} 

fun WarpScript.nextUp(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("NEXTUP", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.nextUp(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("NEXTUP", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.notEqual(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("!="), init) 
} 

fun WarpScript.notEqual(p1: Any, p2: Any, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("!=", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.notEqual(p1: Any? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Any? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("!=", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.notLogical(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("!"), init) 
} 

fun WarpScript.notLogical(value: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("!", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.notLogical(value: Boolean? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("!", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.npdf(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("NPDF"), init) 
} 

fun WarpScript.npdf(mu: Number, sigma: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to mu, 2 to sigma)
    return initTag(Functions("NPDF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.npdf(mu: Number? = null, muElements: Element.() -> Unit = emptyLambda, 
            sigma: Number? = null, sigmaElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to mu, 2 to sigma)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to muElements, 2 to sigmaElements)
    return initTag(Functions("NPDF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.or(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("||"), init) 
} 

fun WarpScript.or(p1: Boolean, p2: Boolean, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("||", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.or(p1: Boolean? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Boolean? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("||", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.orBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("|"), init) 
} 

fun WarpScript.orBitWise(p1: Long, p2: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("|", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.orBitWise(p1: Long? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Long? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("|", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.probability(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("PROBABILITY"), init) 
} 

fun WarpScript.probability(valueHistogram: HashMap<Any,Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to valueHistogram)
    return initTag(Functions("PROBABILITY", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.probability(valueHistogram: HashMap<Any,Number>? = null, valueHistogramElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to valueHistogram)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueHistogramElements)
    return initTag(Functions("PROBABILITY", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rInt(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RINT"), init) 
} 

fun WarpScript.rInt(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("RINT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rInt(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("RINT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rand(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RAND"), init) 
} 

fun WarpScript.randPDF(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("RANDPDF"), init) 
} 

fun WarpScript.randPDF(valueHistogram: HashMap<Any,Number>, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to valueHistogram)
    return initTag(Functions("RANDPDF", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.randPDF(valueHistogram: HashMap<Any,Number>? = null, valueHistogramElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to valueHistogram)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueHistogramElements)
    return initTag(Functions("RANDPDF", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.revBits(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("REVBITS"), init) 
} 

fun WarpScript.revBits(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("REVBITS", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.revBits(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("REVBITS", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALong(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">>"), init) 
} 

fun WarpScript.rightShiftBitsOfALong(number: Long, shiftedBits: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    return initTag(Functions(">>", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALong(number: Long? = null, numberElements: Element.() -> Unit = emptyLambda, 
            shiftedBits: Long? = null, shiftedBitsElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberElements, 2 to shiftedBitsElements)
    return initTag(Functions(">>", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALongWithoutSign(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions(">>>"), init) 
} 

fun WarpScript.rightShiftBitsOfALongWithoutSign(number: Long, shiftedBits: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    return initTag(Functions(">>>", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.rightShiftBitsOfALongWithoutSign(number: Long? = null, numberElements: Element.() -> Unit = emptyLambda, 
            shiftedBits: Long? = null, shiftedBitsElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to number, 2 to shiftedBits)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to numberElements, 2 to shiftedBitsElements)
    return initTag(Functions(">>>", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.round(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("ROUND"), init) 
} 

fun WarpScript.round(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("ROUND", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.round(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("ROUND", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.sigNum(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SIGNUM"), init) 
} 

fun WarpScript.sigNum(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("SIGNUM", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sigNum(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("SIGNUM", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.sqrt(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("SQRT"), init) 
} 

fun WarpScript.sqrt(value: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("SQRT", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sqrt(value: Number? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("SQRT", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.sub(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("-"), init) 
} 

fun WarpScript.sub(p1: Number, p2: Number, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("-", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.sub(p1: Number? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Number? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("-", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.unaryComplementBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("~"), init) 
} 

fun WarpScript.unaryComplementBitWise(value: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    return initTag(Functions("~", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.unaryComplementBitWise(value: Long? = null, valueElements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to value)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to valueElements)
    return initTag(Functions("~", data, elements, this, emptyLambda), init) 
} 

fun WarpScript.xorBitWise(init: Element.() -> Unit = {}) : Functions {
    return initTag(Functions("^"), init) 
} 

fun WarpScript.xorBitWise(p1: Long, p2: Long, init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    return initTag(Functions("^", data, HashMap(), this, emptyLambda), init) 
} 

fun WarpScript.xorBitWise(p1: Long? = null, p1Elements: Element.() -> Unit = emptyLambda, 
            p2: Long? = null, p2Elements: Element.() -> Unit = emptyLambda, 
            init: Element.() -> Unit = {}) : Functions {
    val data = hashMapOf<Number, Any?>(1 to p1, 2 to p2)
    val elements = hashMapOf<Number, Element.() -> Unit>(1 to p1Elements, 2 to p2Elements)
    return initTag(Functions("^", data, elements, this, emptyLambda), init) 
} 
