package io.warp10.generator

import java.io.File

//
// WarpScript KOTLINDSL
// @author aurrelhebert
// @license apache 2.0
//

//
// First WarpScript commands generator
//

fun main(args: Array<String>) {

    val basicFunctions: HashMap<String, ParameterFunction> = JSONParse.parseResourceFile()

    val standaloneData = StringBuilder()

    // Generate Headers
    standaloneData.append("package io.warp10.warpscriptDSL\n \n// \n// WarpScript KOTLINDSL\n")
    standaloneData.append("// @author aurrelhebert \n// @license apache 2.0 \n// \n \n")
    standaloneData.append("// Autogenerated code\n \n")

    val sorted = basicFunctions.toSortedMap()
    for ((k,v) in sorted) {
        standaloneData.append(writeBasicFunction(k,v))
    }

    val file = File("src/main/kotlin/io/warp10/warpscriptDSL/BasicFunction.kt")
    file.writeText(standaloneData.toString())

}

private fun writeBasicFunction(javaName: String, warpScript: ParameterFunction ): String {
    val render = StringBuilder()

    //
    // Write standalone generator function
    //

    render.append("fun WarpScript." + javaName + "(init: Element.() -> Unit = {}) : Functions {\n")
    render.append("    return initTag(Functions(\"" + warpScript.warpScriptName + "\"), init) \n")
    render.append("} \n")
    render.append("\n")

    //
    // If the function have parameters
    //

    if (!warpScript.attributes.isEmpty()) {

        //
        // Write methods based on parameter type
        //

        // Method call generator
        render.append("fun WarpScript." + javaName + "(")
        getParameter(render, warpScript)
        render.append("init: Element.() -> Unit = {}) : Functions {\n")
        val indent = "   "
        getInlineMethod(render, warpScript, indent)
        // Write method content
        render.append("$indent return initTag(Functions(\"" + warpScript.warpScriptName + "\", ")
        render.append("data, HashMap(), this, emptyLambda), init) \n")
        render.append("} \n")
        render.append("\n")
        //
        // Write methods based on elements type (inferring WarpScript)
        //
        render.append("fun WarpScript." + javaName + "(")
        getParameterElements(render, warpScript)
        render.append("init: Element.() -> Unit = {}) : Functions {\n")
        getInlineMethodElements(render, warpScript, indent)
        // Write method content
        render.append("$indent return initTag(Functions(\"" + warpScript.warpScriptName + "\", ")
        render.append("data, elements, this, emptyLambda), init) \n")
        render.append("} \n")
        render.append("\n")

    }
    return render.toString()
}

//
// Generate inside code
//
fun getInlineMethod(render: StringBuilder, warpScript: ParameterFunction,indent: String) {

    render.append("$indent val data = hashMapOf<Number, Any?>(")
    val coreBuilder = StringBuilder()
    for ((k,v: Param) in warpScript.attributes) {
        coreBuilder.append("$k to ${v.name}, ")
    }
    render.append(coreBuilder.toString().removeSuffix(", "))
    render.append(")\n")
}

//
// Generate input attributes
//
fun getParameter(render: StringBuilder, warpScript: ParameterFunction) {
    for ((_,param) in warpScript.attributes) {
        render.append(param.name + ": " +  param.type + ", ")
    }
}

//
// Generate input attributes
//
fun getParameterElements(render: StringBuilder, warpScript: ParameterFunction) {
    for ((_,param) in warpScript.attributes) {
        render.append(param.name + ": " +  param.type + "? = null, "
                + param.name + "Elements: " +  "Element.() -> Unit = emptyLambda, \n            ")
    }
}


//
// Generate inside code for elements function
//
fun getInlineMethodElements(render: StringBuilder, warpScript: ParameterFunction,indent: String) {

    render.append("$indent val data = hashMapOf<Number, Any?>(")
    val coreBuilder = StringBuilder()
    for ((k,v) in warpScript.attributes) {
        coreBuilder.append("$k to ${v.name}, ")
    }
    render.append(coreBuilder.toString().removeSuffix(", "))
    render.append(")\n")

    render.append("$indent val elements = hashMapOf<Number, Element.() -> Unit>(")
    val elementsBuilder = StringBuilder()
    for ((k,v) in warpScript.attributes) {
        elementsBuilder.append("$k to ${v.name}" + "Elements, ")
    }
    render.append(elementsBuilder.toString().removeSuffix(", "))
    render.append(")\n")
}