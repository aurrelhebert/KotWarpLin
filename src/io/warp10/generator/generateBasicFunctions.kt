package io.warp10.generator

import java.io.File

//
// WarpScript KOTLINDSL
// @author aurrelhebert
// @license apache 2.0
//

//
// Standalone Map
// Change NULL to nullWarp
//
val basicFunctions: HashMap<String, ParameterFunction> = hashMapOf(
        "add" to ParameterFunction("+",
                hashMapOf(0 to "p1", 1 to "p2"),
                hashMapOf("p1" to "Any",
                                "p2" to "Any")),
        "now" to ParameterFunction("NOW"),
        "swap" to ParameterFunction("SWAP"),
        "drop" to ParameterFunction("DROP")
)

//
// First WarpScript commands generator
//

fun main(args: Array<String>) {

    val standaloneData = StringBuilder()

    // Generate Headers
    standaloneData.append("package io.warp10.warpscriptDSL\n \n// \n// WarpScript KOTLINDSL\n")
    standaloneData.append("// @author aurrelhebert \n// @license apache 2.0 \n// \n \n")
    standaloneData.append("// Autogenerated code\n \n")

    val sorted = basicFunctions.toSortedMap()
    for ((k,v) in sorted) {
        standaloneData.append(writeBasicFunction(k,v))
    }

    val file = File("src/io/warp10/warpscriptDSL/BasicFunction.kt")
    file.writeText(standaloneData.toString())

}

private fun writeBasicFunction(javaName: String, warpScript: ParameterFunction ): String {
    val render = StringBuilder()

    //
    // Write standalone generator function
    //

    render.append("fun WarpScript." + javaName + "(init: Element.() -> Unit = {}) : Functions {\n")
    render.append("    return initTag(Functions(\"" + warpScript.warpScriptName + "\"), init) \n")
    render.append("} \n")
    render.append("\n")

    //
    // If the function have parameters
    //

    if (!warpScript.attributes.isEmpty()) {

        //
        // Write methods based on parameter type
        //

        // Method call generator
        render.append("fun WarpScript." + javaName + "(")
        getParameter(render, warpScript)
        render.append("init: Element.() -> Unit = {}) : Functions {\n")
        val indent = "   "
        getInlineMethod(render, warpScript, indent)
        // Write method content
        render.append("$indent return initTag(Functions(\"" + warpScript.warpScriptName + "\", ")
        render.append("data, HashMap(), this, emptyLambda), init) \n")
        render.append("} \n")
        render.append("\n")
        //
        // Write methods based on elements type (inferring WarpScript)
        //
        render.append("fun WarpScript." + javaName + "(")
        getParameterElements(render, warpScript)
        render.append("init: Element.() -> Unit = {}) : Functions {\n")
        getInlineMethodElements(render, warpScript, indent)
        // Write method content
        render.append("$indent return initTag(Functions(\"" + warpScript.warpScriptName + "\", ")
        render.append("data, elements, this, emptyLambda), init) \n")
        render.append("} \n")
        render.append("\n")

    }
    return render.toString()
}

//
// Generate inside code
//
fun getInlineMethod(render: StringBuilder, warpScript: ParameterFunction,indent: String) {

    render.append("$indent val data = hashMapOf<Number, Any>(")
    val coreBuilder = StringBuilder()
    for ((k,v) in warpScript.attributes) {
        coreBuilder.append("$k to $v, ")
    }
    render.append(coreBuilder.toString().removeSuffix(", "))
    render.append(")\n")
}

//
// Generate input attributes
//
fun getParameter(render: StringBuilder, warpScript: ParameterFunction) {
    for ((_,param) in warpScript.attributes) {
        if (!warpScript.attributesType.containsKey(param)){
            throw Exception("generation fail cannot retrieve param key: " + param + " in basic function generator")
        }
        render.append(param + ": " +  warpScript.attributesType.get(param) + ", ")
    }
}

//
// Generate input attributes
//
fun getParameterElements(render: StringBuilder, warpScript: ParameterFunction) {
    for ((_,param) in warpScript.attributes) {
        if (!warpScript.attributesType.containsKey(param)){
            throw Exception("generation fail cannot retrieve param key: " + param + " in basic function generator")
        }
        render.append(param + ": " +  warpScript.attributesType.get(param) + ", "
                + param + "Elements: " +  "Element.() -> Unit = emptyLambda, \n            ")
    }
}


//
// Generate inside code for elements function
//
fun getInlineMethodElements(render: StringBuilder, warpScript: ParameterFunction,indent: String) {

    render.append("$indent val data = hashMapOf<Number, Any>(")
    val coreBuilder = StringBuilder()
    for ((k,v) in warpScript.attributes) {
        coreBuilder.append("$k to $v, ")
    }
    render.append(coreBuilder.toString().removeSuffix(", "))
    render.append(")\n")

    render.append("$indent val elements = hashMapOf<Number, Element.() -> Unit>(")
    val elementsBuilder = StringBuilder()
    for ((k,v) in warpScript.attributes) {
        elementsBuilder.append("$k to $v" + "Elements, ")
    }
    render.append(elementsBuilder.toString().removeSuffix(", "))
    render.append(")\n")
}